
my_main.elf:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <__crt0_entry>:
       0:	30005073          	csrwi	mstatus,0

00000004 <__crt0_cpu_csr_init>:
       4:	30401073          	csrw	mie,zero
       8:	00000097          	auipc	ra,0x0
       c:	13408093          	addi	ra,ra,308 # 13c <__crt0_trap_handler>
      10:	30509073          	csrw	mtvec,ra

00000014 <__crt0_pointer_init>:
      14:	80002117          	auipc	sp,0x80002
      18:	fe810113          	addi	sp,sp,-24 # 80001ffc <__crt0_stack_begin+0x0>
      1c:	80000197          	auipc	gp,0x80000
      20:	7e418193          	addi	gp,gp,2020 # 80000800 <__crt0_stack_begin+0xffffe804>

00000024 <__crt0_reg_file_init>:
      24:	00000213          	li	tp,0
      28:	00000293          	li	t0,0
      2c:	00000313          	li	t1,0
      30:	00000393          	li	t2,0
      34:	00000413          	li	s0,0
      38:	00000493          	li	s1,0
      3c:	00000813          	li	a6,0
      40:	00000893          	li	a7,0
      44:	00000913          	li	s2,0
      48:	00000993          	li	s3,0
      4c:	00000a13          	li	s4,0
      50:	00000a93          	li	s5,0
      54:	00000b13          	li	s6,0
      58:	00000b93          	li	s7,0
      5c:	00000c13          	li	s8,0
      60:	00000c93          	li	s9,0
      64:	00000d13          	li	s10,0
      68:	00000d93          	li	s11,0
      6c:	00000e13          	li	t3,0
      70:	00000e93          	li	t4,0
      74:	00000f13          	li	t5,0
      78:	00000f93          	li	t6,0

0000007c <__crt0_copy_data>:
      7c:	00001597          	auipc	a1,0x1
      80:	48c58593          	addi	a1,a1,1164 # 1508 <__RODATA_END__>
      84:	80000617          	auipc	a2,0x80000
      88:	f7c60613          	addi	a2,a2,-132 # 80000000 <__crt0_stack_begin+0xffffe004>
      8c:	80000697          	auipc	a3,0x80000
      90:	f7468693          	addi	a3,a3,-140 # 80000000 <__crt0_stack_begin+0xffffe004>
      94:	00c58e63          	beq	a1,a2,b0 <__crt0_clear_bss>

00000098 <__crt0_copy_data_loop>:
      98:	00d65c63          	bge	a2,a3,b0 <__crt0_clear_bss>
      9c:	0005a703          	lw	a4,0(a1)
      a0:	00e62023          	sw	a4,0(a2)
      a4:	00458593          	addi	a1,a1,4
      a8:	00460613          	addi	a2,a2,4
      ac:	fedff06f          	j	98 <__crt0_copy_data_loop>

000000b0 <__crt0_clear_bss>:
      b0:	80000717          	auipc	a4,0x80000
      b4:	f5070713          	addi	a4,a4,-176 # 80000000 <__crt0_stack_begin+0xffffe004>
      b8:	89418793          	addi	a5,gp,-1900 # 80000094 <__BSS_END__>

000000bc <__crt0_clear_bss_loop>:
      bc:	00f75863          	bge	a4,a5,cc <__crt0_call_constructors>
      c0:	00072023          	sw	zero,0(a4)
      c4:	00470713          	addi	a4,a4,4
      c8:	ff5ff06f          	j	bc <__crt0_clear_bss_loop>

000000cc <__crt0_call_constructors>:
      cc:	00001417          	auipc	s0,0x1
      d0:	f4c40413          	addi	s0,s0,-180 # 1018 <__etext>
      d4:	00001497          	auipc	s1,0x1
      d8:	f4448493          	addi	s1,s1,-188 # 1018 <__etext>

000000dc <__crt0_call_constructors_loop>:
      dc:	00945a63          	bge	s0,s1,f0 <__crt0_call_constructors_loop_end>
      e0:	00042083          	lw	ra,0(s0)
      e4:	000080e7          	jalr	ra
      e8:	00440413          	addi	s0,s0,4
      ec:	ff1ff06f          	j	dc <__crt0_call_constructors_loop>

000000f0 <__crt0_call_constructors_loop_end>:
      f0:	00000513          	li	a0,0
      f4:	00000593          	li	a1,0
      f8:	090000ef          	jal	ra,188 <main>

000000fc <__crt0_main_exit>:
      fc:	30401073          	csrw	mie,zero
     100:	34051073          	csrw	mscratch,a0

00000104 <__crt0_call_destructors>:
     104:	00001417          	auipc	s0,0x1
     108:	f1440413          	addi	s0,s0,-236 # 1018 <__etext>
     10c:	00001497          	auipc	s1,0x1
     110:	f0c48493          	addi	s1,s1,-244 # 1018 <__etext>

00000114 <__crt0_call_destructors_loop>:
     114:	00945a63          	bge	s0,s1,128 <__crt0_call_destructors_loop_end>
     118:	00042083          	lw	ra,0(s0)
     11c:	000080e7          	jalr	ra
     120:	00440413          	addi	s0,s0,4
     124:	ff1ff06f          	j	114 <__crt0_call_destructors_loop>

00000128 <__crt0_call_destructors_loop_end>:
     128:	00000093          	li	ra,0
     12c:	00008463          	beqz	ra,134 <__crt0_main_aftermath_end>
     130:	000080e7          	jalr	ra

00000134 <__crt0_main_aftermath_end>:
     134:	10500073          	wfi
     138:	ffdff06f          	j	134 <__crt0_main_aftermath_end>

0000013c <__crt0_trap_handler>:
     13c:	ff810113          	addi	sp,sp,-8
     140:	00812023          	sw	s0,0(sp)
     144:	00912223          	sw	s1,4(sp)
     148:	34202473          	csrr	s0,mcause
     14c:	02044663          	bltz	s0,178 <__crt0_trap_handler_end>
     150:	34102473          	csrr	s0,mepc
     154:	00041483          	lh	s1,0(s0)
     158:	0034f493          	andi	s1,s1,3
     15c:	00240413          	addi	s0,s0,2
     160:	34141073          	csrw	mepc,s0
     164:	00300413          	li	s0,3
     168:	00941863          	bne	s0,s1,178 <__crt0_trap_handler_end>
     16c:	34102473          	csrr	s0,mepc
     170:	00240413          	addi	s0,s0,2
     174:	34141073          	csrw	mepc,s0

00000178 <__crt0_trap_handler_end>:
     178:	00012403          	lw	s0,0(sp)
     17c:	00412483          	lw	s1,4(sp)
     180:	00810113          	addi	sp,sp,8
     184:	30200073          	mret

00000188 <main>:
 *
 * @note This program requires UART0 and the DMA controller to be synthesized.
 *
 * @return Irrelevant.
 **************************************************************************/
int main() {
     188:	fe010113          	addi	sp,sp,-32
     18c:	00112e23          	sw	ra,28(sp)
     190:	00812c23          	sw	s0,24(sp)
     194:	00912a23          	sw	s1,20(sp)
     198:	01212823          	sw	s2,16(sp)
     19c:	01312623          	sw	s3,12(sp)
     1a0:	01412423          	sw	s4,8(sp)

  uint32_t cmd;
  int rc;

  // setup NEORV32 runtime environment
  neorv32_rte_setup();
     1a4:	0c9000ef          	jal	ra,a6c <neorv32_rte_setup>

  // setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);
     1a8:	fffff437          	lui	s0,0xfffff
     1ac:	000055b7          	lui	a1,0x5
     1b0:	00000613          	li	a2,0
     1b4:	b0058593          	addi	a1,a1,-1280 # 4b00 <__neorv32_ram_size+0x2b00>
     1b8:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     1bc:	241000ef          	jal	ra,bfc <neorv32_uart_setup>

  // intro
  neorv32_uart0_printf("\n<<< DMA Controller Demo Program >>>\n\n");
     1c0:	000015b7          	lui	a1,0x1
     1c4:	0b458593          	addi	a1,a1,180 # 10b4 <__etext+0x9c>
     1c8:	50040513          	addi	a0,s0,1280
     1cc:	351000ef          	jal	ra,d1c <neorv32_uart_printf>

  // check if DMA controller is implemented at all
  if (neorv32_dma_available() == 0) {
     1d0:	2b4000ef          	jal	ra,484 <neorv32_dma_available>
     1d4:	02051c63          	bnez	a0,20c <main+0x84>
    neorv32_uart0_printf("ERROR! DMA controller not implemented!\n");
     1d8:	000015b7          	lui	a1,0x1
     1dc:	50040513          	addi	a0,s0,1280
     1e0:	0dc58593          	addi	a1,a1,220 # 10dc <__etext+0xc4>
     1e4:	339000ef          	jal	ra,d1c <neorv32_uart_printf>
    return 1;
     1e8:	00100513          	li	a0,1
  }

*/
  neorv32_uart0_printf("\nProgram completed.\n");
  return 0;
}
     1ec:	01c12083          	lw	ra,28(sp)
     1f0:	01812403          	lw	s0,24(sp)
     1f4:	01412483          	lw	s1,20(sp)
     1f8:	01012903          	lw	s2,16(sp)
     1fc:	00c12983          	lw	s3,12(sp)
     200:	00812a03          	lw	s4,8(sp)
     204:	02010113          	addi	sp,sp,32
     208:	00008067          	ret
  neorv32_uart0_printf("Source test data:      %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_src[0]));
     20c:	800009b7          	lui	s3,0x80000
     210:	000015b7          	lui	a1,0x1
     214:	01098693          	addi	a3,s3,16 # 80000010 <__crt0_stack_begin+0xffffe014>
     218:	50040513          	addi	a0,s0,1280
     21c:	01000613          	li	a2,16
     220:	10458593          	addi	a1,a1,260 # 1104 <__etext+0xec>
     224:	2f9000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("Destination test data: %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_dst[0]));
     228:	80000a37          	lui	s4,0x80000
     22c:	000015b7          	lui	a1,0x1
     230:	000a0693          	mv	a3,s4
     234:	01000613          	li	a2,16
     238:	50040513          	addi	a0,s0,1280
     23c:	12c58593          	addi	a1,a1,300 # 112c <__etext+0x114>
     240:	2dd000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_rte_handler_install(DMA_RTE_ID, dma_firq_handler);
     244:	39400593          	li	a1,916
     248:	01700513          	li	a0,23
     24c:	7c4000ef          	jal	ra,a10 <neorv32_rte_handler_install>
  neorv32_dma_enable();
     250:	244000ef          	jal	ra,494 <neorv32_dma_enable>
  dma_src[0] = 0x66778899UL;
     254:	667797b7          	lui	a5,0x66779
  neorv32_uart0_printf("Source test data:      %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_src[0]));
     258:	01098493          	addi	s1,s3,16
  dma_src[0] = 0x66778899UL;
     25c:	89978793          	addi	a5,a5,-1895 # 66778899 <__neorv32_ram_size+0x66776899>
     260:	00f4a023          	sw	a5,0(s1)
  dma_src[1] = 0x22334455UL;
     264:	223347b7          	lui	a5,0x22334
     268:	45578793          	addi	a5,a5,1109 # 22334455 <__neorv32_ram_size+0x22332455>
     26c:	00f4a223          	sw	a5,4(s1)
  dma_src[2] = 0xaabbccddUL;
     270:	aabbd7b7          	lui	a5,0xaabbd
     274:	cdd78793          	addi	a5,a5,-803 # aabbccdd <__crt0_stack_begin+0x2abbace1>
     278:	00f4a423          	sw	a5,8(s1)
  dma_src[3] = 0x0011eeffUL;
     27c:	0011f7b7          	lui	a5,0x11f
     280:	eff78793          	addi	a5,a5,-257 # 11eeff <__neorv32_ram_size+0x11ceff>
  neorv32_uart0_printf("Destination test data: %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_dst[0]));
     284:	000a0913          	mv	s2,s4
  dma_src[3] = 0x0011eeffUL;
     288:	00f4a623          	sw	a5,12(s1)
  dma_dst[0] = 0;
     28c:	00092023          	sw	zero,0(s2)
  dma_dst[1] = 0;
     290:	00092223          	sw	zero,4(s2)
  dma_dst[2] = 0;
     294:	00092423          	sw	zero,8(s2)
  dma_dst[3] = 0;
     298:	00092623          	sw	zero,12(s2)
  asm volatile ("fence"); // make sure main memory is sync with d-cache
     29c:	0ff0000f          	fence
  neorv32_uart0_printf("\nExample 1: Manual byte-to-byte block transfer with Endianness conversion using busy wait.\n");
     2a0:	000015b7          	lui	a1,0x1
     2a4:	50040513          	addi	a0,s0,1280
     2a8:	15458593          	addi	a1,a1,340 # 1154 <__etext+0x13c>
     2ac:	271000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_dma_transfer((uint32_t)(&dma_src[0]), // source array base address - byte-aligned!
     2b0:	01098513          	addi	a0,s3,16
     2b4:	e00006b7          	lui	a3,0xe0000
     2b8:	01000613          	li	a2,16
     2bc:	000a0593          	mv	a1,s4
     2c0:	1e8000ef          	jal	ra,4a8 <neorv32_dma_transfer>
  neorv32_uart0_printf("Waiting for DMA... ");
     2c4:	000019b7          	lui	s3,0x1
     2c8:	50040513          	addi	a0,s0,1280
     2cc:	1b098593          	addi	a1,s3,432 # 11b0 <__etext+0x198>
     2d0:	24d000ef          	jal	ra,d1c <neorv32_uart_printf>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     2d4:	00100413          	li	s0,1
    rc = neorv32_dma_status();
     2d8:	20c000ef          	jal	ra,4e4 <neorv32_dma_status>
    if (rc == DMA_STATUS_IDLE) {
     2dc:	08051863          	bnez	a0,36c <main+0x1e4>
      neorv32_uart0_printf("Transfer done.\n");
     2e0:	000015b7          	lui	a1,0x1
     2e4:	1c458593          	addi	a1,a1,452 # 11c4 <__etext+0x1ac>
      neorv32_uart0_printf("Transfer failed!\n");
     2e8:	fffff537          	lui	a0,0xfffff
     2ec:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     2f0:	22d000ef          	jal	ra,d1c <neorv32_uart_printf>
  show_arrays();
     2f4:	0bc000ef          	jal	ra,3b0 <show_arrays>
  neorv32_uart0_printf("\nExample 2: Manual word-to-word one-to-many transfer using busy wait.\n");
     2f8:	fffff437          	lui	s0,0xfffff
     2fc:	000015b7          	lui	a1,0x1
     300:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     304:	1e858593          	addi	a1,a1,488 # 11e8 <__etext+0x1d0>
     308:	215000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_dma_transfer((uint32_t)(&dma_src[0]), // source array base address - word-aligned!
     30c:	580006b7          	lui	a3,0x58000
     310:	00400613          	li	a2,4
     314:	00090593          	mv	a1,s2
     318:	00048513          	mv	a0,s1
     31c:	18c000ef          	jal	ra,4a8 <neorv32_dma_transfer>
  neorv32_uart0_printf("Waiting for DMA... ");
     320:	50040513          	addi	a0,s0,1280
     324:	1b098593          	addi	a1,s3,432
     328:	1f5000ef          	jal	ra,d1c <neorv32_uart_printf>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     32c:	00100413          	li	s0,1
    rc = neorv32_dma_status();
     330:	1b4000ef          	jal	ra,4e4 <neorv32_dma_status>
    if (rc == DMA_STATUS_IDLE) {
     334:	04051663          	bnez	a0,380 <main+0x1f8>
      neorv32_uart0_printf("Transfer done.\n");
     338:	000015b7          	lui	a1,0x1
     33c:	1c458593          	addi	a1,a1,452 # 11c4 <__etext+0x1ac>
      neorv32_uart0_printf("Transfer failed!\n");
     340:	fffff537          	lui	a0,0xfffff
     344:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     348:	1d5000ef          	jal	ra,d1c <neorv32_uart_printf>
  show_arrays();
     34c:	064000ef          	jal	ra,3b0 <show_arrays>
  neorv32_uart0_printf("\nProgram completed.\n");
     350:	000015b7          	lui	a1,0x1
     354:	fffff537          	lui	a0,0xfffff
     358:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     35c:	23058593          	addi	a1,a1,560 # 1230 <__etext+0x218>
     360:	1bd000ef          	jal	ra,d1c <neorv32_uart_printf>
  return 0;
     364:	00000513          	li	a0,0
     368:	e85ff06f          	j	1ec <main+0x64>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     36c:	00250513          	addi	a0,a0,2
     370:	f6a464e3          	bltu	s0,a0,2d8 <main+0x150>
      neorv32_uart0_printf("Transfer failed!\n");
     374:	000015b7          	lui	a1,0x1
     378:	1d458593          	addi	a1,a1,468 # 11d4 <__etext+0x1bc>
     37c:	f6dff06f          	j	2e8 <main+0x160>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     380:	00250513          	addi	a0,a0,2
     384:	faa466e3          	bltu	s0,a0,330 <main+0x1a8>
      neorv32_uart0_printf("Transfer failed!\n");
     388:	000015b7          	lui	a1,0x1
     38c:	1d458593          	addi	a1,a1,468 # 11d4 <__etext+0x1bc>
     390:	fb1ff06f          	j	340 <main+0x1b8>

00000394 <dma_firq_handler>:
 **************************************************************************/
inline void __attribute__ ((always_inline)) neorv32_cpu_csr_clr(const int csr_id, uint32_t mask) {

  uint32_t csr_data = mask;

  asm volatile ("csrc %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     394:	040007b7          	lui	a5,0x4000
     398:	3447b073          	csrc	mip,a5
 * @warning This function has to be of type "void xyz(void)" and must not use any interrupt attributes!
 **************************************************************************/
void dma_firq_handler(void) {

  neorv32_cpu_csr_clr(CSR_MIP, 1 << DMA_FIRQ_PENDING); // clear/ack pending FIRQ
  neorv32_uart0_printf("<<DMA interrupt>>\n");
     39c:	000015b7          	lui	a1,0x1
     3a0:	fffff537          	lui	a0,0xfffff
     3a4:	01858593          	addi	a1,a1,24 # 1018 <__etext>
     3a8:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     3ac:	1710006f          	j	d1c <neorv32_uart_printf>

000003b0 <show_arrays>:
void show_arrays(void) {
     3b0:	fe010113          	addi	sp,sp,-32
     3b4:	00112e23          	sw	ra,28(sp)
     3b8:	00812c23          	sw	s0,24(sp)
     3bc:	00912a23          	sw	s1,20(sp)
     3c0:	01212823          	sw	s2,16(sp)
     3c4:	01312623          	sw	s3,12(sp)
  asm volatile ("fence"); // make sure main memory is sync with d-cache
     3c8:	0ff0000f          	fence
  neorv32_uart0_printf("---------------------------\n");
     3cc:	fffff437          	lui	s0,0xfffff
     3d0:	000019b7          	lui	s3,0x1
     3d4:	02c98593          	addi	a1,s3,44 # 102c <__etext+0x14>
     3d8:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     3dc:	141000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("     SRC         DST\n");
     3e0:	000015b7          	lui	a1,0x1
     3e4:	50040513          	addi	a0,s0,1280
     3e8:	04c58593          	addi	a1,a1,76 # 104c <__etext+0x34>
  neorv32_uart0_printf("[0]  0x%x  0x%x\n", dma_src[0], dma_dst[0]);
     3ec:	80000937          	lui	s2,0x80000
     3f0:	800004b7          	lui	s1,0x80000
  neorv32_uart0_printf("     SRC         DST\n");
     3f4:	129000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("[0]  0x%x  0x%x\n", dma_src[0], dma_dst[0]);
     3f8:	01090913          	addi	s2,s2,16 # 80000010 <__crt0_stack_begin+0xffffe014>
     3fc:	00048493          	mv	s1,s1
     400:	00092603          	lw	a2,0(s2)
     404:	0004a683          	lw	a3,0(s1) # 80000000 <__crt0_stack_begin+0xffffe004>
     408:	000015b7          	lui	a1,0x1
     40c:	50040513          	addi	a0,s0,1280
     410:	06458593          	addi	a1,a1,100 # 1064 <__etext+0x4c>
     414:	109000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("[1]  0x%x  0x%x\n", dma_src[1], dma_dst[1]);
     418:	00492603          	lw	a2,4(s2)
     41c:	0044a683          	lw	a3,4(s1)
     420:	000015b7          	lui	a1,0x1
     424:	50040513          	addi	a0,s0,1280
     428:	07858593          	addi	a1,a1,120 # 1078 <__etext+0x60>
     42c:	0f1000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("[2]  0x%x  0x%x\n", dma_src[2], dma_dst[2]);
     430:	00892603          	lw	a2,8(s2)
     434:	0084a683          	lw	a3,8(s1)
     438:	000015b7          	lui	a1,0x1
     43c:	50040513          	addi	a0,s0,1280
     440:	08c58593          	addi	a1,a1,140 # 108c <__etext+0x74>
     444:	0d9000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("[3]  0x%x  0x%x\n", dma_src[3], dma_dst[3]);
     448:	00c92603          	lw	a2,12(s2)
     44c:	00c4a683          	lw	a3,12(s1)
     450:	000015b7          	lui	a1,0x1
     454:	50040513          	addi	a0,s0,1280
     458:	0a058593          	addi	a1,a1,160 # 10a0 <__etext+0x88>
     45c:	0c1000ef          	jal	ra,d1c <neorv32_uart_printf>
  neorv32_uart0_printf("---------------------------\n");
     460:	50040513          	addi	a0,s0,1280
}
     464:	01812403          	lw	s0,24(sp)
     468:	01c12083          	lw	ra,28(sp)
     46c:	01412483          	lw	s1,20(sp)
     470:	01012903          	lw	s2,16(sp)
  neorv32_uart0_printf("---------------------------\n");
     474:	02c98593          	addi	a1,s3,44
}
     478:	00c12983          	lw	s3,12(sp)
     47c:	02010113          	addi	sp,sp,32
  neorv32_uart0_printf("---------------------------\n");
     480:	09d0006f          	j	d1c <neorv32_uart_printf>

00000484 <neorv32_dma_available>:
 *
 * @return 0 if DMA was not synthesized, 1 if DMA is available.
 **************************************************************************/
int neorv32_dma_available(void) {

  if (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_DMA)) {
     484:	e0802503          	lw	a0,-504(zero) # fffffe08 <__crt0_stack_begin+0x7fffde0c>
     488:	00e55513          	srli	a0,a0,0xe
    return 1;
  }
  else {
    return 0;
  }
}
     48c:	00157513          	andi	a0,a0,1
     490:	00008067          	ret

00000494 <neorv32_dma_enable>:
/**********************************************************************//**
 * Enable DMA.
 **************************************************************************/
void neorv32_dma_enable(void) {

  NEORV32_DMA->CTRL |= (uint32_t)(1 << DMA_CTRL_EN);
     494:	fffff737          	lui	a4,0xfffff
     498:	d0072783          	lw	a5,-768(a4) # ffffed00 <__crt0_stack_begin+0x7fffcd04>
     49c:	0017e793          	ori	a5,a5,1
     4a0:	d0f72023          	sw	a5,-768(a4)
}
     4a4:	00008067          	ret

000004a8 <neorv32_dma_transfer>:
 * @param[in] num Number of elements to transfer (24-bit).
 * @param[in] config Transfer type configuration/commands.
 **************************************************************************/
void neorv32_dma_transfer(uint32_t base_src, uint32_t base_dst, uint32_t num, uint32_t config) {

  NEORV32_DMA->CTRL &= ~((uint32_t)(1 << DMA_CTRL_AUTO)); // manual transfer trigger
     4a8:	fffff737          	lui	a4,0xfffff
     4ac:	d0072803          	lw	a6,-768(a4) # ffffed00 <__crt0_stack_begin+0x7fffcd04>
  NEORV32_DMA->SRC_BASE = base_src+3;
     4b0:	00350513          	addi	a0,a0,3
  NEORV32_DMA->CTRL &= ~((uint32_t)(1 << DMA_CTRL_AUTO)); // manual transfer trigger
     4b4:	d0070793          	addi	a5,a4,-768
     4b8:	ffd87813          	andi	a6,a6,-3
     4bc:	d1072023          	sw	a6,-768(a4)
  NEORV32_DMA->SRC_BASE = base_src+3;
     4c0:	d0a72223          	sw	a0,-764(a4)
  NEORV32_DMA->DST_BASE = base_dst;
     4c4:	d0b72423          	sw	a1,-760(a4)
  NEORV32_DMA->TTYPE    = (num & 0x00ffffffUL) | (config & 0xff000000UL); // trigger transfer
     4c8:	00861613          	slli	a2,a2,0x8
     4cc:	ff000737          	lui	a4,0xff000
     4d0:	00865613          	srli	a2,a2,0x8
     4d4:	00e6f6b3          	and	a3,a3,a4
     4d8:	00d66633          	or	a2,a2,a3
     4dc:	00c7a623          	sw	a2,12(a5) # 400000c <__neorv32_ram_size+0x3ffe00c>
}
     4e0:	00008067          	ret

000004e4 <neorv32_dma_status>:
 *
 * @return Current DMA status (#NEORV32_DMA_STATUS_enum)
 **************************************************************************/
int neorv32_dma_status(void) {

  uint32_t tmp = NEORV32_DMA->CTRL;
     4e4:	fffff7b7          	lui	a5,0xfffff
     4e8:	d007a783          	lw	a5,-768(a5) # ffffed00 <__crt0_stack_begin+0x7fffcd04>

  if (tmp & (1 << DMA_CTRL_ERROR_WR)) {
    return DMA_STATUS_ERR_WR; // error during write access
     4ec:	ffe00513          	li	a0,-2
  if (tmp & (1 << DMA_CTRL_ERROR_WR)) {
     4f0:	2007f713          	andi	a4,a5,512
     4f4:	00071c63          	bnez	a4,50c <neorv32_dma_status+0x28>
  }
  else if (tmp & (1 << DMA_CTRL_ERROR_RD)) {
     4f8:	1007f713          	andi	a4,a5,256
    return DMA_STATUS_ERR_RD; // error during read access
     4fc:	fff00513          	li	a0,-1
  else if (tmp & (1 << DMA_CTRL_ERROR_RD)) {
     500:	00071663          	bnez	a4,50c <neorv32_dma_status+0x28>
  }
  else if (tmp & (1 << DMA_CTRL_BUSY)) {
     504:	00a7d793          	srli	a5,a5,0xa
     508:	0017f513          	andi	a0,a5,1
    return DMA_STATUS_BUSY; // transfer in progress
  }
  else {
    return DMA_STATUS_IDLE; // idle
  }
}
     50c:	00008067          	ret

00000510 <__neorv32_rte_core>:
/**********************************************************************//**
 * This is the [private!] core of the NEORV32 RTE.
 *
 * @warning When using the RTE this function is the ONLY function that uses the 'interrupt' attribute!
 **************************************************************************/
static void __attribute__((__interrupt__)) __attribute__((aligned(4))) __neorv32_rte_core(void) {
     510:	fb010113          	addi	sp,sp,-80
     514:	04112623          	sw	ra,76(sp)
     518:	04512423          	sw	t0,72(sp)
     51c:	04612223          	sw	t1,68(sp)
     520:	04712023          	sw	t2,64(sp)
     524:	02812e23          	sw	s0,60(sp)
     528:	02a12c23          	sw	a0,56(sp)
     52c:	02b12a23          	sw	a1,52(sp)
     530:	02c12823          	sw	a2,48(sp)
     534:	02d12623          	sw	a3,44(sp)
     538:	02e12423          	sw	a4,40(sp)
     53c:	02f12223          	sw	a5,36(sp)
     540:	03012023          	sw	a6,32(sp)
     544:	01112e23          	sw	a7,28(sp)
     548:	01c12c23          	sw	t3,24(sp)
     54c:	01d12a23          	sw	t4,20(sp)
     550:	01e12823          	sw	t5,16(sp)
     554:	01f12623          	sw	t6,12(sp)
 **************************************************************************/
inline uint32_t __attribute__ ((always_inline)) neorv32_cpu_csr_read(const int csr_id) {

  uint32_t csr_data;

  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     558:	34202473          	csrr	s0,mcause

  uint32_t rte_mcause = neorv32_cpu_csr_read(CSR_MCAUSE);

  // find according trap handler
  uint32_t rte_handler;
  switch (rte_mcause) {
     55c:	00b00793          	li	a5,11
     560:	0287ea63          	bltu	a5,s0,594 <__neorv32_rte_core+0x84>
     564:	00001737          	lui	a4,0x1
     568:	00241793          	slli	a5,s0,0x2
     56c:	24870713          	addi	a4,a4,584 # 1248 <__etext+0x230>
     570:	00e787b3          	add	a5,a5,a4
     574:	0007a783          	lw	a5,0(a5)
     578:	00078067          	jr	a5
     57c:	00001737          	lui	a4,0x1
     580:	00279793          	slli	a5,a5,0x2
     584:	27870713          	addi	a4,a4,632 # 1278 <__etext+0x260>
     588:	00e787b3          	add	a5,a5,a4
     58c:	0007a783          	lw	a5,0(a5)
     590:	00078067          	jr	a5
     594:	800007b7          	lui	a5,0x80000
     598:	ffd7c793          	xori	a5,a5,-3
     59c:	00f407b3          	add	a5,s0,a5
     5a0:	01c00713          	li	a4,28
     5a4:	fcf77ce3          	bgeu	a4,a5,57c <__neorv32_rte_core+0x6c>
  }

  // execute handler
  void (*handler_pnt)(void);
  handler_pnt = (void*)rte_handler;
  (*handler_pnt)();
     5a8:	234000ef          	jal	ra,7dc <__neorv32_rte_debug_handler>

  // compute return address
  if ((((int32_t)rte_mcause) >= 0) && // modify pc only if not interrupt (MSB cleared)
     5ac:	00045a63          	bgez	s0,5c0 <__neorv32_rte_core+0xb0>
     5b0:	0500006f          	j	600 <__neorv32_rte_core+0xf0>
  (*handler_pnt)();
     5b4:	800007b7          	lui	a5,0x80000
     5b8:	0207a783          	lw	a5,32(a5) # 80000020 <__crt0_stack_begin+0xffffe024>
     5bc:	000780e7          	jalr	a5
     5c0:	34102773          	csrr	a4,mepc
  asm volatile ("lbu %[da], 0(%[ad])" : [da] "=r" (reg_data) : [ad] "r" (reg_addr));
     5c4:	00074783          	lbu	a5,0(a4)
     5c8:	0ff7f793          	zext.b	a5,a5
    uint32_t rte_mepc = neorv32_cpu_csr_read(CSR_MEPC);

    // get opcode of faulting instruction
    uint32_t rte_trap_inst = (uint32_t)neorv32_cpu_load_unsigned_byte(rte_mepc);

    rte_mepc += 4; // default: faulting instruction is uncompressed
     5cc:	00470613          	addi	a2,a4,4
  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     5d0:	301026f3          	csrr	a3,misa
    if (neorv32_cpu_csr_read(CSR_MISA) & (1 << CSR_MISA_C)) { // C extension implemented?
     5d4:	0046f693          	andi	a3,a3,4
     5d8:	00068a63          	beqz	a3,5ec <__neorv32_rte_core+0xdc>
      if ((rte_trap_inst & 3) != 3) { // faulting instruction is compressed instruction
     5dc:	0037f793          	andi	a5,a5,3
     5e0:	00300693          	li	a3,3
     5e4:	00d78463          	beq	a5,a3,5ec <__neorv32_rte_core+0xdc>
        rte_mepc -= 2;
     5e8:	00270613          	addi	a2,a4,2
 **************************************************************************/
inline void __attribute__ ((always_inline)) neorv32_cpu_csr_write(const int csr_id, uint32_t data) {

  uint32_t csr_data = data;

  asm volatile ("csrw %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     5ec:	34161073          	csrw	mepc,a2
    }

    // store new return address
    neorv32_cpu_csr_write(CSR_MEPC, rte_mepc);
  }
}
     5f0:	0100006f          	j	600 <__neorv32_rte_core+0xf0>
    case TRAP_CODE_I_ACCESS:     rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_I_ACCESS]; break;
     5f4:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     5f8:	0247a783          	lw	a5,36(a5) # 80000024 <__crt0_stack_begin+0xffffe028>
     5fc:	000780e7          	jalr	a5
}
     600:	03c12403          	lw	s0,60(sp)
     604:	04c12083          	lw	ra,76(sp)
     608:	04812283          	lw	t0,72(sp)
     60c:	04412303          	lw	t1,68(sp)
     610:	04012383          	lw	t2,64(sp)
     614:	03812503          	lw	a0,56(sp)
     618:	03412583          	lw	a1,52(sp)
     61c:	03012603          	lw	a2,48(sp)
     620:	02c12683          	lw	a3,44(sp)
     624:	02812703          	lw	a4,40(sp)
     628:	02412783          	lw	a5,36(sp)
     62c:	02012803          	lw	a6,32(sp)
     630:	01c12883          	lw	a7,28(sp)
     634:	01812e03          	lw	t3,24(sp)
     638:	01412e83          	lw	t4,20(sp)
     63c:	01012f03          	lw	t5,16(sp)
     640:	00c12f83          	lw	t6,12(sp)
     644:	05010113          	addi	sp,sp,80
     648:	30200073          	mret
    case TRAP_CODE_I_ILLEGAL:    rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_I_ILLEGAL]; break;
     64c:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     650:	0287a783          	lw	a5,40(a5) # 80000028 <__crt0_stack_begin+0xffffe02c>
     654:	f69ff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_BREAKPOINT:   rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_BREAKPOINT]; break;
     658:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     65c:	02c7a783          	lw	a5,44(a5) # 8000002c <__crt0_stack_begin+0xffffe030>
     660:	f5dff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_L_MISALIGNED: rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_L_MISALIGNED]; break;
     664:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     668:	0307a783          	lw	a5,48(a5) # 80000030 <__crt0_stack_begin+0xffffe034>
     66c:	f51ff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_L_ACCESS:     rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_L_ACCESS]; break;
     670:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     674:	0347a783          	lw	a5,52(a5) # 80000034 <__crt0_stack_begin+0xffffe038>
     678:	f45ff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_S_MISALIGNED: rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_S_MISALIGNED]; break;
     67c:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     680:	0387a783          	lw	a5,56(a5) # 80000038 <__crt0_stack_begin+0xffffe03c>
     684:	f39ff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_S_ACCESS:     rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_S_ACCESS]; break;
     688:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     68c:	03c7a783          	lw	a5,60(a5) # 8000003c <__crt0_stack_begin+0xffffe040>
     690:	f2dff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_UENV_CALL:    rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_UENV_CALL]; break;
     694:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     698:	0407a783          	lw	a5,64(a5) # 80000040 <__crt0_stack_begin+0xffffe044>
     69c:	f21ff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_MENV_CALL:    rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_MENV_CALL]; break;
     6a0:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     6a4:	0447a783          	lw	a5,68(a5) # 80000044 <__crt0_stack_begin+0xffffe048>
     6a8:	f15ff06f          	j	5bc <__neorv32_rte_core+0xac>
    case TRAP_CODE_MSI:          rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_MSI]; break;
     6ac:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     6b0:	0487a783          	lw	a5,72(a5) # 80000048 <__crt0_stack_begin+0xffffe04c>
     6b4:	f49ff06f          	j	5fc <__neorv32_rte_core+0xec>
    case TRAP_CODE_MTI:          rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_MTI]; break;
     6b8:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     6bc:	04c7a783          	lw	a5,76(a5) # 8000004c <__crt0_stack_begin+0xffffe050>
     6c0:	f3dff06f          	j	5fc <__neorv32_rte_core+0xec>
     6c4:	8501a783          	lw	a5,-1968(gp) # 80000050 <__neorv32_rte_vector_lut+0x30>
     6c8:	f35ff06f          	j	5fc <__neorv32_rte_core+0xec>
     6cc:	8541a783          	lw	a5,-1964(gp) # 80000054 <__neorv32_rte_vector_lut+0x34>
     6d0:	f2dff06f          	j	5fc <__neorv32_rte_core+0xec>
     6d4:	8581a783          	lw	a5,-1960(gp) # 80000058 <__neorv32_rte_vector_lut+0x38>
     6d8:	f25ff06f          	j	5fc <__neorv32_rte_core+0xec>
     6dc:	85c1a783          	lw	a5,-1956(gp) # 8000005c <__neorv32_rte_vector_lut+0x3c>
     6e0:	f1dff06f          	j	5fc <__neorv32_rte_core+0xec>
     6e4:	8601a783          	lw	a5,-1952(gp) # 80000060 <__neorv32_rte_vector_lut+0x40>
     6e8:	f15ff06f          	j	5fc <__neorv32_rte_core+0xec>
     6ec:	8641a783          	lw	a5,-1948(gp) # 80000064 <__neorv32_rte_vector_lut+0x44>
     6f0:	f0dff06f          	j	5fc <__neorv32_rte_core+0xec>
     6f4:	8681a783          	lw	a5,-1944(gp) # 80000068 <__neorv32_rte_vector_lut+0x48>
     6f8:	f05ff06f          	j	5fc <__neorv32_rte_core+0xec>
     6fc:	86c1a783          	lw	a5,-1940(gp) # 8000006c <__neorv32_rte_vector_lut+0x4c>
     700:	efdff06f          	j	5fc <__neorv32_rte_core+0xec>
     704:	8701a783          	lw	a5,-1936(gp) # 80000070 <__neorv32_rte_vector_lut+0x50>
     708:	ef5ff06f          	j	5fc <__neorv32_rte_core+0xec>
     70c:	8741a783          	lw	a5,-1932(gp) # 80000074 <__neorv32_rte_vector_lut+0x54>
     710:	eedff06f          	j	5fc <__neorv32_rte_core+0xec>
     714:	8781a783          	lw	a5,-1928(gp) # 80000078 <__neorv32_rte_vector_lut+0x58>
     718:	ee5ff06f          	j	5fc <__neorv32_rte_core+0xec>
     71c:	87c1a783          	lw	a5,-1924(gp) # 8000007c <__neorv32_rte_vector_lut+0x5c>
     720:	eddff06f          	j	5fc <__neorv32_rte_core+0xec>
     724:	8801a783          	lw	a5,-1920(gp) # 80000080 <__neorv32_rte_vector_lut+0x60>
     728:	ed5ff06f          	j	5fc <__neorv32_rte_core+0xec>
     72c:	8841a783          	lw	a5,-1916(gp) # 80000084 <__neorv32_rte_vector_lut+0x64>
     730:	ecdff06f          	j	5fc <__neorv32_rte_core+0xec>
     734:	8881a783          	lw	a5,-1912(gp) # 80000088 <__neorv32_rte_vector_lut+0x68>
     738:	ec5ff06f          	j	5fc <__neorv32_rte_core+0xec>
     73c:	88c1a783          	lw	a5,-1908(gp) # 8000008c <__neorv32_rte_vector_lut+0x6c>
     740:	ebdff06f          	j	5fc <__neorv32_rte_core+0xec>
     744:	8901a783          	lw	a5,-1904(gp) # 80000090 <__neorv32_rte_vector_lut+0x70>
     748:	eb5ff06f          	j	5fc <__neorv32_rte_core+0xec>

0000074c <__neorv32_rte_print_hex_word>:
 * NEORV32 runtime environment: Private function to print 32-bit number
 * as 8-digit hexadecimal value (with "0x" suffix).
 *
 * @param[in] num Number to print as hexadecimal.
 **************************************************************************/
void __neorv32_rte_print_hex_word(uint32_t num) {
     74c:	fe010113          	addi	sp,sp,-32
     750:	00812c23          	sw	s0,24(sp)

  static const char hex_symbols[16] = "0123456789ABCDEF";

  neorv32_uart0_putc('0');
     754:	fffff437          	lui	s0,0xfffff
void __neorv32_rte_print_hex_word(uint32_t num) {
     758:	01312623          	sw	s3,12(sp)
  neorv32_uart0_putc('0');
     75c:	03000593          	li	a1,48
void __neorv32_rte_print_hex_word(uint32_t num) {
     760:	00050993          	mv	s3,a0
  neorv32_uart0_putc('0');
     764:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
void __neorv32_rte_print_hex_word(uint32_t num) {
     768:	00112e23          	sw	ra,28(sp)
     76c:	00912a23          	sw	s1,20(sp)
     770:	01212823          	sw	s2,16(sp)
     774:	01412423          	sw	s4,8(sp)
  neorv32_uart0_putc('0');
     778:	520000ef          	jal	ra,c98 <neorv32_uart_putc>
  neorv32_uart0_putc('x');
     77c:	50040513          	addi	a0,s0,1280
     780:	07800593          	li	a1,120

  int i;
  for (i=0; i<8; i++) {
    uint32_t index = (num >> (28 - 4*i)) & 0xF;
    neorv32_uart0_putc(hex_symbols[index]);
     784:	00001937          	lui	s2,0x1
  neorv32_uart0_putc('x');
     788:	510000ef          	jal	ra,c98 <neorv32_uart_putc>
     78c:	01c00493          	li	s1,28
    neorv32_uart0_putc(hex_symbols[index]);
     790:	4d890913          	addi	s2,s2,1240 # 14d8 <hex_symbols.0>
     794:	50040413          	addi	s0,s0,1280
  for (i=0; i<8; i++) {
     798:	ffc00a13          	li	s4,-4
    uint32_t index = (num >> (28 - 4*i)) & 0xF;
     79c:	0099d7b3          	srl	a5,s3,s1
     7a0:	00f7f793          	andi	a5,a5,15
    neorv32_uart0_putc(hex_symbols[index]);
     7a4:	00f907b3          	add	a5,s2,a5
     7a8:	0007c583          	lbu	a1,0(a5)
     7ac:	00040513          	mv	a0,s0
  for (i=0; i<8; i++) {
     7b0:	ffc48493          	addi	s1,s1,-4
    neorv32_uart0_putc(hex_symbols[index]);
     7b4:	4e4000ef          	jal	ra,c98 <neorv32_uart_putc>
  for (i=0; i<8; i++) {
     7b8:	ff4492e3          	bne	s1,s4,79c <__neorv32_rte_print_hex_word+0x50>
  }
}
     7bc:	01c12083          	lw	ra,28(sp)
     7c0:	01812403          	lw	s0,24(sp)
     7c4:	01412483          	lw	s1,20(sp)
     7c8:	01012903          	lw	s2,16(sp)
     7cc:	00c12983          	lw	s3,12(sp)
     7d0:	00812a03          	lw	s4,8(sp)
     7d4:	02010113          	addi	sp,sp,32
     7d8:	00008067          	ret

000007dc <__neorv32_rte_debug_handler>:
static void __neorv32_rte_debug_handler(void) {
     7dc:	ff010113          	addi	sp,sp,-16
     7e0:	00812423          	sw	s0,8(sp)
  if (neorv32_uart0_available() == 0) {
     7e4:	fffff437          	lui	s0,0xfffff
     7e8:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
static void __neorv32_rte_debug_handler(void) {
     7ec:	00112623          	sw	ra,12(sp)
     7f0:	00912223          	sw	s1,4(sp)
  if (neorv32_uart0_available() == 0) {
     7f4:	3d0000ef          	jal	ra,bc4 <neorv32_uart_available>
     7f8:	20050263          	beqz	a0,9fc <__neorv32_rte_debug_handler+0x220>
  neorv32_uart0_puts("<RTE> ");
     7fc:	000015b7          	lui	a1,0x1
     800:	2ec58593          	addi	a1,a1,748 # 12ec <__etext+0x2d4>
     804:	50040513          	addi	a0,s0,1280
     808:	4a8000ef          	jal	ra,cb0 <neorv32_uart_puts>
  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     80c:	300027f3          	csrr	a5,mstatus
  if (neorv32_cpu_csr_read(CSR_MSTATUS) & (3 << CSR_MSTATUS_MPP_L)) {
     810:	00002737          	lui	a4,0x2
     814:	80070713          	addi	a4,a4,-2048 # 1800 <__RODATA_END__+0x2f8>
     818:	00e7f7b3          	and	a5,a5,a4
     81c:	02078c63          	beqz	a5,854 <__neorv32_rte_debug_handler+0x78>
    neorv32_uart0_puts("[M] "); // machine-mode
     820:	000015b7          	lui	a1,0x1
     824:	2f458593          	addi	a1,a1,756 # 12f4 <__etext+0x2dc>
    neorv32_uart0_puts("[U] "); // user-mode
     828:	50040513          	addi	a0,s0,1280
     82c:	484000ef          	jal	ra,cb0 <neorv32_uart_puts>
     830:	34202473          	csrr	s0,mcause
  switch (trap_cause) {
     834:	00b00793          	li	a5,11
     838:	0287e463          	bltu	a5,s0,860 <__neorv32_rte_debug_handler+0x84>
     83c:	00001737          	lui	a4,0x1
     840:	00241793          	slli	a5,s0,0x2
     844:	4a870713          	addi	a4,a4,1192 # 14a8 <__etext+0x490>
     848:	00e787b3          	add	a5,a5,a4
     84c:	0007a783          	lw	a5,0(a5)
     850:	00078067          	jr	a5
    neorv32_uart0_puts("[U] "); // user-mode
     854:	000015b7          	lui	a1,0x1
     858:	2fc58593          	addi	a1,a1,764 # 12fc <__etext+0x2e4>
     85c:	fcdff06f          	j	828 <__neorv32_rte_debug_handler+0x4c>
  switch (trap_cause) {
     860:	800007b7          	lui	a5,0x80000
     864:	00b78713          	addi	a4,a5,11 # 8000000b <__crt0_stack_begin+0xffffe00f>
     868:	16e40463          	beq	s0,a4,9d0 <__neorv32_rte_debug_handler+0x1f4>
     86c:	02876a63          	bltu	a4,s0,8a0 <__neorv32_rte_debug_handler+0xc4>
     870:	00378713          	addi	a4,a5,3
     874:	14e40263          	beq	s0,a4,9b8 <__neorv32_rte_debug_handler+0x1dc>
     878:	00778793          	addi	a5,a5,7
     87c:	14f40463          	beq	s0,a5,9c4 <__neorv32_rte_debug_handler+0x1e8>
    default:                     neorv32_uart0_puts("UNKNOWN trap cause "); __neorv32_rte_print_hex_word(trap_cause); break;
     880:	000015b7          	lui	a1,0x1
     884:	fffff537          	lui	a0,0xfffff
     888:	44c58593          	addi	a1,a1,1100 # 144c <__etext+0x434>
     88c:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     890:	420000ef          	jal	ra,cb0 <neorv32_uart_puts>
     894:	00040513          	mv	a0,s0
     898:	eb5ff0ef          	jal	ra,74c <__neorv32_rte_print_hex_word>
  if ((trap_cause >= TRAP_CODE_FIRQ_0) && (trap_cause <= TRAP_CODE_FIRQ_15)) {
     89c:	05c0006f          	j	8f8 <__neorv32_rte_debug_handler+0x11c>
  switch (trap_cause) {
     8a0:	ff07c793          	xori	a5,a5,-16
     8a4:	00f407b3          	add	a5,s0,a5
     8a8:	00f00713          	li	a4,15
     8ac:	fcf76ae3          	bltu	a4,a5,880 <__neorv32_rte_debug_handler+0xa4>
    case TRAP_CODE_FIRQ_15:      neorv32_uart0_puts("Fast IRQ "); __neorv32_rte_print_hex_word(trap_cause & 0xf); break;
     8b0:	000015b7          	lui	a1,0x1
     8b4:	fffff537          	lui	a0,0xfffff
     8b8:	44058593          	addi	a1,a1,1088 # 1440 <__etext+0x428>
     8bc:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     8c0:	3f0000ef          	jal	ra,cb0 <neorv32_uart_puts>
     8c4:	00f47493          	andi	s1,s0,15
     8c8:	00048513          	mv	a0,s1
     8cc:	e81ff0ef          	jal	ra,74c <__neorv32_rte_print_hex_word>
    neorv32_cpu_csr_clr(CSR_MIP, 1 << (CSR_MIP_FIRQ0P + (trap_cause & 0xf))); // clear pending FIRQ
     8d0:	01048493          	addi	s1,s1,16
     8d4:	00100793          	li	a5,1
     8d8:	009797b3          	sll	a5,a5,s1
 **************************************************************************/
inline void __attribute__ ((always_inline)) neorv32_cpu_csr_clr(const int csr_id, uint32_t mask) {

  uint32_t csr_data = mask;

  asm volatile ("csrc %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     8dc:	3447b073          	csrc	mip,a5
}
     8e0:	0180006f          	j	8f8 <__neorv32_rte_debug_handler+0x11c>
    case TRAP_CODE_I_MISALIGNED: neorv32_uart0_puts("Instruction address misaligned"); break;
     8e4:	000015b7          	lui	a1,0x1
     8e8:	30458593          	addi	a1,a1,772 # 1304 <__etext+0x2ec>
    case TRAP_CODE_MEI:          neorv32_uart0_puts("Machine external IRQ"); break;
     8ec:	fffff537          	lui	a0,0xfffff
     8f0:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     8f4:	3bc000ef          	jal	ra,cb0 <neorv32_uart_puts>
  neorv32_uart0_puts(" @ PC=");
     8f8:	fffff4b7          	lui	s1,0xfffff
     8fc:	000015b7          	lui	a1,0x1
     900:	46058593          	addi	a1,a1,1120 # 1460 <__etext+0x448>
     904:	50048513          	addi	a0,s1,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     908:	3a8000ef          	jal	ra,cb0 <neorv32_uart_puts>
  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     90c:	34102573          	csrr	a0,mepc
  __neorv32_rte_print_hex_word(mepc);
     910:	e3dff0ef          	jal	ra,74c <__neorv32_rte_print_hex_word>
  neorv32_uart0_puts(", MTVAL=");
     914:	000015b7          	lui	a1,0x1
     918:	46858593          	addi	a1,a1,1128 # 1468 <__etext+0x450>
     91c:	50048513          	addi	a0,s1,1280
     920:	390000ef          	jal	ra,cb0 <neorv32_uart_puts>
     924:	34302573          	csrr	a0,mtval
  __neorv32_rte_print_hex_word(neorv32_cpu_csr_read(CSR_MTVAL));
     928:	e25ff0ef          	jal	ra,74c <__neorv32_rte_print_hex_word>
  if ((trap_cause == TRAP_CODE_I_ACCESS) || (trap_cause == TRAP_CODE_I_MISALIGNED)) {
     92c:	00100793          	li	a5,1
     930:	0a87e663          	bltu	a5,s0,9dc <__neorv32_rte_debug_handler+0x200>
    neorv32_uart0_puts(" [FATAL EXCEPTION] Halting CPU. </RTE>\n");
     934:	000015b7          	lui	a1,0x1
     938:	47458593          	addi	a1,a1,1140 # 1474 <__etext+0x45c>
     93c:	50048513          	addi	a0,s1,1280
     940:	370000ef          	jal	ra,cb0 <neorv32_uart_puts>
      asm volatile ("wfi");
     944:	10500073          	wfi
    while(1) {
     948:	ffdff06f          	j	944 <__neorv32_rte_debug_handler+0x168>
    case TRAP_CODE_I_ACCESS:     neorv32_uart0_puts("Instruction access fault"); break;
     94c:	000015b7          	lui	a1,0x1
     950:	32458593          	addi	a1,a1,804 # 1324 <__etext+0x30c>
     954:	f99ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_I_ILLEGAL:    neorv32_uart0_puts("Illegal instruction"); break;
     958:	000015b7          	lui	a1,0x1
     95c:	34058593          	addi	a1,a1,832 # 1340 <__etext+0x328>
     960:	f8dff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_BREAKPOINT:   neorv32_uart0_puts("Breakpoint"); break;
     964:	000015b7          	lui	a1,0x1
     968:	35458593          	addi	a1,a1,852 # 1354 <__etext+0x33c>
     96c:	f81ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_L_MISALIGNED: neorv32_uart0_puts("Load address misaligned"); break;
     970:	000015b7          	lui	a1,0x1
     974:	36058593          	addi	a1,a1,864 # 1360 <__etext+0x348>
     978:	f75ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_L_ACCESS:     neorv32_uart0_puts("Load access fault"); break;
     97c:	000015b7          	lui	a1,0x1
     980:	37858593          	addi	a1,a1,888 # 1378 <__etext+0x360>
     984:	f69ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_S_MISALIGNED: neorv32_uart0_puts("Store address misaligned"); break;
     988:	000015b7          	lui	a1,0x1
     98c:	38c58593          	addi	a1,a1,908 # 138c <__etext+0x374>
     990:	f5dff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_S_ACCESS:     neorv32_uart0_puts("Store access fault"); break;
     994:	000015b7          	lui	a1,0x1
     998:	3a858593          	addi	a1,a1,936 # 13a8 <__etext+0x390>
     99c:	f51ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_UENV_CALL:    neorv32_uart0_puts("Environment call from U-mode"); break;
     9a0:	000015b7          	lui	a1,0x1
     9a4:	3bc58593          	addi	a1,a1,956 # 13bc <__etext+0x3a4>
     9a8:	f45ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MENV_CALL:    neorv32_uart0_puts("Environment call from M-mode"); break;
     9ac:	000015b7          	lui	a1,0x1
     9b0:	3dc58593          	addi	a1,a1,988 # 13dc <__etext+0x3c4>
     9b4:	f39ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MSI:          neorv32_uart0_puts("Machine software IRQ"); break;
     9b8:	000015b7          	lui	a1,0x1
     9bc:	3fc58593          	addi	a1,a1,1020 # 13fc <__etext+0x3e4>
     9c0:	f2dff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MTI:          neorv32_uart0_puts("Machine timer IRQ"); break;
     9c4:	000015b7          	lui	a1,0x1
     9c8:	41458593          	addi	a1,a1,1044 # 1414 <__etext+0x3fc>
     9cc:	f21ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MEI:          neorv32_uart0_puts("Machine external IRQ"); break;
     9d0:	000015b7          	lui	a1,0x1
     9d4:	42858593          	addi	a1,a1,1064 # 1428 <__etext+0x410>
     9d8:	f15ff06f          	j	8ec <__neorv32_rte_debug_handler+0x110>
}
     9dc:	00812403          	lw	s0,8(sp)
     9e0:	00c12083          	lw	ra,12(sp)
  neorv32_uart0_puts(" </RTE>\n");
     9e4:	50048513          	addi	a0,s1,1280
}
     9e8:	00412483          	lw	s1,4(sp)
  neorv32_uart0_puts(" </RTE>\n");
     9ec:	000015b7          	lui	a1,0x1
     9f0:	49c58593          	addi	a1,a1,1180 # 149c <__etext+0x484>
}
     9f4:	01010113          	addi	sp,sp,16
  neorv32_uart0_puts(" </RTE>\n");
     9f8:	2b80006f          	j	cb0 <neorv32_uart_puts>
}
     9fc:	00c12083          	lw	ra,12(sp)
     a00:	00812403          	lw	s0,8(sp)
     a04:	00412483          	lw	s1,4(sp)
     a08:	01010113          	addi	sp,sp,16
     a0c:	00008067          	ret

00000a10 <neorv32_rte_handler_install>:
  if ((id >= (int)RTE_TRAP_I_MISALIGNED) && (id <= (int)RTE_TRAP_FIRQ_15)) {
     a10:	01c00793          	li	a5,28
     a14:	02a7e063          	bltu	a5,a0,a34 <neorv32_rte_handler_install+0x24>
    __neorv32_rte_vector_lut[id] = (uint32_t)handler; // install handler
     a18:	800007b7          	lui	a5,0x80000
     a1c:	00251513          	slli	a0,a0,0x2
     a20:	02078793          	addi	a5,a5,32 # 80000020 <__crt0_stack_begin+0xffffe024>
     a24:	00a787b3          	add	a5,a5,a0
     a28:	00b7a023          	sw	a1,0(a5)
    return 0;
     a2c:	00000513          	li	a0,0
     a30:	00008067          	ret
  return 1;
     a34:	00100513          	li	a0,1
}
     a38:	00008067          	ret

00000a3c <neorv32_rte_handler_uninstall>:
  if ((id >= (int)RTE_TRAP_I_MISALIGNED) && (id <= (int)RTE_TRAP_FIRQ_15)) {
     a3c:	01c00793          	li	a5,28
     a40:	02a7e263          	bltu	a5,a0,a64 <neorv32_rte_handler_uninstall+0x28>
    __neorv32_rte_vector_lut[id] = (uint32_t)(&__neorv32_rte_debug_handler); // use dummy handler in case the trap is accidentally triggered
     a44:	800007b7          	lui	a5,0x80000
     a48:	00251513          	slli	a0,a0,0x2
     a4c:	02078793          	addi	a5,a5,32 # 80000020 <__crt0_stack_begin+0xffffe024>
     a50:	00a787b3          	add	a5,a5,a0
     a54:	7dc00713          	li	a4,2012
     a58:	00e7a023          	sw	a4,0(a5)
    return 0;
     a5c:	00000513          	li	a0,0
     a60:	00008067          	ret
  return 1;
     a64:	00100513          	li	a0,1
}
     a68:	00008067          	ret

00000a6c <neorv32_rte_setup>:
void neorv32_rte_setup(void) {
     a6c:	ff010113          	addi	sp,sp,-16
     a70:	00112623          	sw	ra,12(sp)
     a74:	00812423          	sw	s0,8(sp)
     a78:	00912223          	sw	s1,4(sp)
  asm volatile ("csrw %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     a7c:	51000793          	li	a5,1296
     a80:	30579073          	csrw	mtvec,a5
     a84:	00000793          	li	a5,0
     a88:	30479073          	csrw	mie,a5
     a8c:	34479073          	csrw	mip,a5
     a90:	00000413          	li	s0,0
  for (id = 0; id < (sizeof(__neorv32_rte_vector_lut)/sizeof(__neorv32_rte_vector_lut[0])); id++) {
     a94:	01d00493          	li	s1,29
    neorv32_rte_handler_uninstall(id); // this will configure the debug handler
     a98:	00040513          	mv	a0,s0
  for (id = 0; id < (sizeof(__neorv32_rte_vector_lut)/sizeof(__neorv32_rte_vector_lut[0])); id++) {
     a9c:	00140413          	addi	s0,s0,1
    neorv32_rte_handler_uninstall(id); // this will configure the debug handler
     aa0:	f9dff0ef          	jal	ra,a3c <neorv32_rte_handler_uninstall>
  for (id = 0; id < (sizeof(__neorv32_rte_vector_lut)/sizeof(__neorv32_rte_vector_lut[0])); id++) {
     aa4:	fe941ae3          	bne	s0,s1,a98 <neorv32_rte_setup+0x2c>
}
     aa8:	00c12083          	lw	ra,12(sp)
     aac:	00812403          	lw	s0,8(sp)
     ab0:	00412483          	lw	s1,4(sp)
     ab4:	01010113          	addi	sp,sp,16
     ab8:	00008067          	ret

00000abc <__neorv32_uart_itoa>:
 * Private function for 'neorv32_printf' to convert into decimal.
 *
 * @param[in] x Unsigned input number.
 * @param[in,out] res Pointer for storing the reuslting number string (11 chars).
 **************************************************************************/
static void __neorv32_uart_itoa(uint32_t x, char *res) {
     abc:	fd010113          	addi	sp,sp,-48
     ac0:	02812423          	sw	s0,40(sp)
     ac4:	02912223          	sw	s1,36(sp)
     ac8:	03212023          	sw	s2,32(sp)
     acc:	01312e23          	sw	s3,28(sp)
     ad0:	01412c23          	sw	s4,24(sp)
     ad4:	02112623          	sw	ra,44(sp)
     ad8:	01512a23          	sw	s5,20(sp)
  buffer1[10] = '\0';
  res[10] = '\0';

  // convert
  for (i=0; i<10; i++) {
    buffer1[i] = numbers[x%10];
     adc:	00001a37          	lui	s4,0x1
static void __neorv32_uart_itoa(uint32_t x, char *res) {
     ae0:	00050493          	mv	s1,a0
     ae4:	00058413          	mv	s0,a1
  res[10] = '\0';
     ae8:	00058523          	sb	zero,10(a1)
     aec:	00000993          	li	s3,0
    buffer1[i] = numbers[x%10];
     af0:	00410913          	addi	s2,sp,4
     af4:	4fca0a13          	addi	s4,s4,1276 # 14fc <numbers.1>
     af8:	00a00593          	li	a1,10
     afc:	00048513          	mv	a0,s1
     b00:	4b4000ef          	jal	ra,fb4 <__umodsi3>
     b04:	00aa0533          	add	a0,s4,a0
     b08:	00054783          	lbu	a5,0(a0)
     b0c:	01390ab3          	add	s5,s2,s3
    x /= 10;
     b10:	00048513          	mv	a0,s1
    buffer1[i] = numbers[x%10];
     b14:	00fa8023          	sb	a5,0(s5)
    x /= 10;
     b18:	00a00593          	li	a1,10
     b1c:	450000ef          	jal	ra,f6c <__hidden___udivsi3>
  for (i=0; i<10; i++) {
     b20:	00198993          	addi	s3,s3,1
     b24:	00a00793          	li	a5,10
    x /= 10;
     b28:	00050493          	mv	s1,a0
  for (i=0; i<10; i++) {
     b2c:	fcf996e3          	bne	s3,a5,af8 <__neorv32_uart_itoa+0x3c>
     b30:	00090693          	mv	a3,s2
  }

  // delete 'leading' zeros
  for (i=9; i!=0; i--) {
     b34:	00900713          	li	a4,9
    if (buffer1[i] == '0')
     b38:	03000613          	li	a2,48
     b3c:	0096c583          	lbu	a1,9(a3) # 58000009 <__neorv32_ram_size+0x57ffe009>
     b40:	00070793          	mv	a5,a4
  for (i=9; i!=0; i--) {
     b44:	fff70713          	addi	a4,a4,-1
     b48:	01071713          	slli	a4,a4,0x10
     b4c:	01075713          	srli	a4,a4,0x10
    if (buffer1[i] == '0')
     b50:	00c59a63          	bne	a1,a2,b64 <__neorv32_uart_itoa+0xa8>
      buffer1[i] = '\0';
     b54:	000684a3          	sb	zero,9(a3)
  for (i=9; i!=0; i--) {
     b58:	fff68693          	addi	a3,a3,-1
     b5c:	fe0710e3          	bnez	a4,b3c <__neorv32_uart_itoa+0x80>
     b60:	00000793          	li	a5,0
     b64:	00f907b3          	add	a5,s2,a5
     b68:	00000713          	li	a4,0
  }

  // reverse
  j = 0;
  do {
    if (buffer1[i] != '\0')
     b6c:	0007c683          	lbu	a3,0(a5)
     b70:	00068c63          	beqz	a3,b88 <__neorv32_uart_itoa+0xcc>
      res[j++] = buffer1[i];
     b74:	00170613          	addi	a2,a4,1
     b78:	00e40733          	add	a4,s0,a4
     b7c:	00d70023          	sb	a3,0(a4)
     b80:	01061713          	slli	a4,a2,0x10
     b84:	01075713          	srli	a4,a4,0x10
  } while (i--);
     b88:	fff78693          	addi	a3,a5,-1
     b8c:	02f91863          	bne	s2,a5,bbc <__neorv32_uart_itoa+0x100>

  res[j] = '\0'; // terminate result string
     b90:	00e40433          	add	s0,s0,a4
     b94:	00040023          	sb	zero,0(s0)
}
     b98:	02c12083          	lw	ra,44(sp)
     b9c:	02812403          	lw	s0,40(sp)
     ba0:	02412483          	lw	s1,36(sp)
     ba4:	02012903          	lw	s2,32(sp)
     ba8:	01c12983          	lw	s3,28(sp)
     bac:	01812a03          	lw	s4,24(sp)
     bb0:	01412a83          	lw	s5,20(sp)
     bb4:	03010113          	addi	sp,sp,48
     bb8:	00008067          	ret
     bbc:	00068793          	mv	a5,a3
     bc0:	fadff06f          	j	b6c <__neorv32_uart_itoa+0xb0>

00000bc4 <neorv32_uart_available>:
  if ( ((uint32_t)UARTx == NEORV32_UART0_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART0)) ) {
     bc4:	fffff7b7          	lui	a5,0xfffff
     bc8:	50078693          	addi	a3,a5,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
int neorv32_uart_available (neorv32_uart_t *UARTx) {
     bcc:	00050713          	mv	a4,a0
  if ( ((uint32_t)UARTx == NEORV32_UART0_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART0)) ) {
     bd0:	00d51a63          	bne	a0,a3,be4 <neorv32_uart_available+0x20>
     bd4:	e0802503          	lw	a0,-504(zero) # fffffe08 <__crt0_stack_begin+0x7fffde0c>
     bd8:	01155513          	srli	a0,a0,0x11
  if ( ((uint32_t)UARTx == NEORV32_UART1_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART1)) ) {
     bdc:	00157513          	andi	a0,a0,1
}
     be0:	00008067          	ret
  if ( ((uint32_t)UARTx == NEORV32_UART1_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART1)) ) {
     be4:	60078793          	addi	a5,a5,1536
  int available = 0;
     be8:	00000513          	li	a0,0
  if ( ((uint32_t)UARTx == NEORV32_UART1_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART1)) ) {
     bec:	fef71ae3          	bne	a4,a5,be0 <neorv32_uart_available+0x1c>
     bf0:	e0802503          	lw	a0,-504(zero) # fffffe08 <__crt0_stack_begin+0x7fffde0c>
     bf4:	01955513          	srli	a0,a0,0x19
     bf8:	fe5ff06f          	j	bdc <neorv32_uart_available+0x18>

00000bfc <neorv32_uart_setup>:
void neorv32_uart_setup(neorv32_uart_t *UARTx, uint32_t baudrate, uint32_t irq_mask) {
     bfc:	ff010113          	addi	sp,sp,-16
     c00:	00812423          	sw	s0,8(sp)
     c04:	00912223          	sw	s1,4(sp)
     c08:	00112623          	sw	ra,12(sp)
  UARTx->CTRL = 0;
     c0c:	00052023          	sw	zero,0(a0)
void neorv32_uart_setup(neorv32_uart_t *UARTx, uint32_t baudrate, uint32_t irq_mask) {
     c10:	00050493          	mv	s1,a0
  uint32_t clock = NEORV32_SYSINFO->CLK; // system clock in Hz
     c14:	e0002503          	lw	a0,-512(zero) # fffffe00 <__crt0_stack_begin+0x7fffde04>
  baud_div = clock / (2*baudrate);
     c18:	00159593          	slli	a1,a1,0x1
void neorv32_uart_setup(neorv32_uart_t *UARTx, uint32_t baudrate, uint32_t irq_mask) {
     c1c:	00060413          	mv	s0,a2
  baud_div = clock / (2*baudrate);
     c20:	34c000ef          	jal	ra,f6c <__hidden___udivsi3>
  uint32_t prsc_sel = 0;
     c24:	00000713          	li	a4,0
  while (baud_div >= 0x3ffU) {
     c28:	3fe00693          	li	a3,1022
     c2c:	04a6e663          	bltu	a3,a0,c78 <neorv32_uart_setup+0x7c>
  tmp |= (uint32_t)((baud_div - 1) & 0x3ffU) << UART_CTRL_BAUD0;
     c30:	fff50793          	addi	a5,a0,-1
     c34:	000106b7          	lui	a3,0x10
     c38:	fff68693          	addi	a3,a3,-1 # ffff <__neorv32_ram_size+0xdfff>
     c3c:	00679793          	slli	a5,a5,0x6
     c40:	00d7f7b3          	and	a5,a5,a3
  tmp |= (uint32_t)(irq_mask & (0x1fU << UART_CTRL_IRQ_RX_NEMPTY));
     c44:	07c006b7          	lui	a3,0x7c00
     c48:	00d47433          	and	s0,s0,a3
  tmp |= (uint32_t)(prsc_sel       & 3U)     << UART_CTRL_PRSC0;
     c4c:	00371713          	slli	a4,a4,0x3
  tmp |= (uint32_t)(irq_mask & (0x1fU << UART_CTRL_IRQ_RX_NEMPTY));
     c50:	0087e7b3          	or	a5,a5,s0
  tmp |= (uint32_t)(prsc_sel       & 3U)     << UART_CTRL_PRSC0;
     c54:	01877713          	andi	a4,a4,24
}
     c58:	00c12083          	lw	ra,12(sp)
     c5c:	00812403          	lw	s0,8(sp)
  tmp |= (uint32_t)(irq_mask & (0x1fU << UART_CTRL_IRQ_RX_NEMPTY));
     c60:	00e7e7b3          	or	a5,a5,a4
     c64:	0017e793          	ori	a5,a5,1
  UARTx->CTRL = tmp;
     c68:	00f4a023          	sw	a5,0(s1)
}
     c6c:	00412483          	lw	s1,4(sp)
     c70:	01010113          	addi	sp,sp,16
     c74:	00008067          	ret
    if ((prsc_sel == 2) || (prsc_sel == 4))
     c78:	ffe70793          	addi	a5,a4,-2
     c7c:	ffd7f793          	andi	a5,a5,-3
     c80:	00079863          	bnez	a5,c90 <neorv32_uart_setup+0x94>
      baud_div >>= 3;
     c84:	00355513          	srli	a0,a0,0x3
    prsc_sel++;
     c88:	00170713          	addi	a4,a4,1
     c8c:	fa1ff06f          	j	c2c <neorv32_uart_setup+0x30>
      baud_div >>= 1;
     c90:	00155513          	srli	a0,a0,0x1
     c94:	ff5ff06f          	j	c88 <neorv32_uart_setup+0x8c>

00000c98 <neorv32_uart_putc>:
  while ((UARTx->CTRL & (1<<UART_CTRL_TX_FULL))); // wait for free space in TX FIFO
     c98:	00200737          	lui	a4,0x200
     c9c:	00052783          	lw	a5,0(a0)
     ca0:	00e7f7b3          	and	a5,a5,a4
     ca4:	fe079ce3          	bnez	a5,c9c <neorv32_uart_putc+0x4>
  UARTx->DATA = (uint32_t)c << UART_DATA_RTX_LSB;
     ca8:	00b52223          	sw	a1,4(a0)
}
     cac:	00008067          	ret

00000cb0 <neorv32_uart_puts>:
void neorv32_uart_puts(neorv32_uart_t *UARTx, const char *s) {
     cb0:	fe010113          	addi	sp,sp,-32
     cb4:	00812c23          	sw	s0,24(sp)
     cb8:	00912a23          	sw	s1,20(sp)
     cbc:	01312623          	sw	s3,12(sp)
     cc0:	00112e23          	sw	ra,28(sp)
     cc4:	01212823          	sw	s2,16(sp)
     cc8:	00050493          	mv	s1,a0
     ccc:	00058413          	mv	s0,a1
    if (c == '\n') {
     cd0:	00a00993          	li	s3,10
  while ((c = *s++)) {
     cd4:	00044903          	lbu	s2,0(s0)
     cd8:	00140413          	addi	s0,s0,1
     cdc:	02091063          	bnez	s2,cfc <neorv32_uart_puts+0x4c>
}
     ce0:	01c12083          	lw	ra,28(sp)
     ce4:	01812403          	lw	s0,24(sp)
     ce8:	01412483          	lw	s1,20(sp)
     cec:	01012903          	lw	s2,16(sp)
     cf0:	00c12983          	lw	s3,12(sp)
     cf4:	02010113          	addi	sp,sp,32
     cf8:	00008067          	ret
    if (c == '\n') {
     cfc:	01391863          	bne	s2,s3,d0c <neorv32_uart_puts+0x5c>
      neorv32_uart_putc(UARTx, '\r');
     d00:	00d00593          	li	a1,13
     d04:	00048513          	mv	a0,s1
     d08:	f91ff0ef          	jal	ra,c98 <neorv32_uart_putc>
    neorv32_uart_putc(UARTx, c);
     d0c:	00090593          	mv	a1,s2
     d10:	00048513          	mv	a0,s1
     d14:	f85ff0ef          	jal	ra,c98 <neorv32_uart_putc>
     d18:	fbdff06f          	j	cd4 <neorv32_uart_puts+0x24>

00000d1c <neorv32_uart_printf>:
void neorv32_uart_printf(neorv32_uart_t *UARTx, const char *format, ...) {
     d1c:	fa010113          	addi	sp,sp,-96
     d20:	04f12a23          	sw	a5,84(sp)
  va_start(a, format);
     d24:	04810793          	addi	a5,sp,72
void neorv32_uart_printf(neorv32_uart_t *UARTx, const char *format, ...) {
     d28:	02912a23          	sw	s1,52(sp)
     d2c:	03212823          	sw	s2,48(sp)
     d30:	03312623          	sw	s3,44(sp)
     d34:	03412423          	sw	s4,40(sp)
     d38:	03512223          	sw	s5,36(sp)
     d3c:	03612023          	sw	s6,32(sp)
     d40:	01712e23          	sw	s7,28(sp)
     d44:	01812c23          	sw	s8,24(sp)
     d48:	01912a23          	sw	s9,20(sp)
     d4c:	01a12823          	sw	s10,16(sp)
     d50:	02112e23          	sw	ra,60(sp)
     d54:	02812c23          	sw	s0,56(sp)
     d58:	00050493          	mv	s1,a0
     d5c:	00058913          	mv	s2,a1
     d60:	04c12423          	sw	a2,72(sp)
     d64:	04d12623          	sw	a3,76(sp)
     d68:	04e12823          	sw	a4,80(sp)
     d6c:	05012c23          	sw	a6,88(sp)
     d70:	05112e23          	sw	a7,92(sp)
  va_start(a, format);
     d74:	00f12023          	sw	a5,0(sp)
    if (c == '%') {
     d78:	02500993          	li	s3,37
      if (c == '\n') {
     d7c:	00a00b93          	li	s7,10
      switch (c) {
     d80:	06900a13          	li	s4,105
     d84:	07500a93          	li	s5,117
     d88:	07800c13          	li	s8,120
     d8c:	07000c93          	li	s9,112
     d90:	07300d13          	li	s10,115
     d94:	06300b13          	li	s6,99
  while ((c = *format++)) {
     d98:	00094403          	lbu	s0,0(s2)
     d9c:	02041e63          	bnez	s0,dd8 <neorv32_uart_printf+0xbc>
}
     da0:	03c12083          	lw	ra,60(sp)
     da4:	03812403          	lw	s0,56(sp)
     da8:	03412483          	lw	s1,52(sp)
     dac:	03012903          	lw	s2,48(sp)
     db0:	02c12983          	lw	s3,44(sp)
     db4:	02812a03          	lw	s4,40(sp)
     db8:	02412a83          	lw	s5,36(sp)
     dbc:	02012b03          	lw	s6,32(sp)
     dc0:	01c12b83          	lw	s7,28(sp)
     dc4:	01812c03          	lw	s8,24(sp)
     dc8:	01412c83          	lw	s9,20(sp)
     dcc:	01012d03          	lw	s10,16(sp)
     dd0:	06010113          	addi	sp,sp,96
     dd4:	00008067          	ret
    if (c == '%') {
     dd8:	17341463          	bne	s0,s3,f40 <neorv32_uart_printf+0x224>
      c = *format++;
     ddc:	00194403          	lbu	s0,1(s2)
      switch (c) {
     de0:	03440e63          	beq	s0,s4,e1c <neorv32_uart_printf+0x100>
     de4:	068a6863          	bltu	s4,s0,e54 <neorv32_uart_printf+0x138>
     de8:	13640263          	beq	s0,s6,f0c <neorv32_uart_printf+0x1f0>
     dec:	028b6463          	bltu	s6,s0,e14 <neorv32_uart_printf+0xf8>
          neorv32_uart_putc(UARTx, '%');
     df0:	02500593          	li	a1,37
      switch (c) {
     df4:	13340463          	beq	s0,s3,f1c <neorv32_uart_printf+0x200>
     df8:	05800793          	li	a5,88
     dfc:	08f40663          	beq	s0,a5,e88 <neorv32_uart_printf+0x16c>
          neorv32_uart_putc(UARTx, '%');
     e00:	02500593          	li	a1,37
     e04:	00048513          	mv	a0,s1
     e08:	e91ff0ef          	jal	ra,c98 <neorv32_uart_putc>
          neorv32_uart_putc(UARTx, c);
     e0c:	00040593          	mv	a1,s0
     e10:	10c0006f          	j	f1c <neorv32_uart_printf+0x200>
      switch (c) {
     e14:	06400793          	li	a5,100
     e18:	fef414e3          	bne	s0,a5,e00 <neorv32_uart_printf+0xe4>
          n = (int32_t)va_arg(a, int32_t);
     e1c:	00012783          	lw	a5,0(sp)
     e20:	0007a403          	lw	s0,0(a5)
     e24:	00478713          	addi	a4,a5,4
     e28:	00e12023          	sw	a4,0(sp)
          if (n < 0) {
     e2c:	00045a63          	bgez	s0,e40 <neorv32_uart_printf+0x124>
            neorv32_uart_putc(UARTx, '-');
     e30:	02d00593          	li	a1,45
     e34:	00048513          	mv	a0,s1
            n = -n;
     e38:	40800433          	neg	s0,s0
            neorv32_uart_putc(UARTx, '-');
     e3c:	e5dff0ef          	jal	ra,c98 <neorv32_uart_putc>
          __neorv32_uart_itoa((uint32_t)n, string_buf);
     e40:	00410593          	addi	a1,sp,4
     e44:	00040513          	mv	a0,s0
          __neorv32_uart_itoa(va_arg(a, uint32_t), string_buf);
     e48:	c75ff0ef          	jal	ra,abc <__neorv32_uart_itoa>
          neorv32_uart_puts(UARTx, string_buf);
     e4c:	00410593          	addi	a1,sp,4
     e50:	0240006f          	j	e74 <neorv32_uart_printf+0x158>
      switch (c) {
     e54:	0d540a63          	beq	s0,s5,f28 <neorv32_uart_printf+0x20c>
     e58:	028ae663          	bltu	s5,s0,e84 <neorv32_uart_printf+0x168>
     e5c:	03940663          	beq	s0,s9,e88 <neorv32_uart_printf+0x16c>
     e60:	fba410e3          	bne	s0,s10,e00 <neorv32_uart_printf+0xe4>
          neorv32_uart_puts(UARTx, va_arg(a, char*));
     e64:	00012783          	lw	a5,0(sp)
     e68:	0007a583          	lw	a1,0(a5)
     e6c:	00478713          	addi	a4,a5,4
     e70:	00e12023          	sw	a4,0(sp)
          neorv32_uart_puts(UARTx, string_buf);
     e74:	00048513          	mv	a0,s1
     e78:	e39ff0ef          	jal	ra,cb0 <neorv32_uart_puts>
      c = *format++;
     e7c:	00290913          	addi	s2,s2,2
     e80:	f19ff06f          	j	d98 <neorv32_uart_printf+0x7c>
      switch (c) {
     e84:	f7841ee3          	bne	s0,s8,e00 <neorv32_uart_printf+0xe4>
          __neorv32_uart_tohex(va_arg(a, uint32_t), string_buf);
     e88:	00012783          	lw	a5,0(sp)
     e8c:	00410693          	addi	a3,sp,4
  static const char symbols[] = "0123456789abcdef";

  int i;
  for (i=0; i<8; i++) { // nibble by nibble
    uint32_t num_tmp = x >> (4*i);
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     e90:	00001637          	lui	a2,0x1
          __neorv32_uart_tohex(va_arg(a, uint32_t), string_buf);
     e94:	0007a803          	lw	a6,0(a5)
     e98:	00478713          	addi	a4,a5,4
     e9c:	00e12023          	sw	a4,0(sp)
     ea0:	00068593          	mv	a1,a3
     ea4:	00000713          	li	a4,0
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     ea8:	4e860613          	addi	a2,a2,1256 # 14e8 <symbols.0>
  for (i=0; i<8; i++) { // nibble by nibble
     eac:	02000513          	li	a0,32
    uint32_t num_tmp = x >> (4*i);
     eb0:	00e857b3          	srl	a5,a6,a4
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     eb4:	00f7f793          	andi	a5,a5,15
     eb8:	00f607b3          	add	a5,a2,a5
     ebc:	0007c783          	lbu	a5,0(a5)
  for (i=0; i<8; i++) { // nibble by nibble
     ec0:	00470713          	addi	a4,a4,4 # 200004 <__neorv32_ram_size+0x1fe004>
     ec4:	fff68693          	addi	a3,a3,-1 # 7bfffff <__neorv32_ram_size+0x7bfdfff>
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     ec8:	00f68423          	sb	a5,8(a3)
  for (i=0; i<8; i++) { // nibble by nibble
     ecc:	fea712e3          	bne	a4,a0,eb0 <neorv32_uart_printf+0x194>
  }

  res[8] = '\0'; // terminate result string
     ed0:	00010623          	sb	zero,12(sp)
          if (c == 'X') {
     ed4:	05800793          	li	a5,88
     ed8:	f8f41ee3          	bne	s0,a5,e74 <neorv32_uart_printf+0x158>
     edc:	00058793          	mv	a5,a1

  char tmp;

  while (len > 0) {
    tmp = *ptr;
    if ((tmp >= 'a') && (tmp <= 'z')) {
     ee0:	01900513          	li	a0,25
  while (len > 0) {
     ee4:	00f10613          	addi	a2,sp,15
    tmp = *ptr;
     ee8:	0007c703          	lbu	a4,0(a5)
    if ((tmp >= 'a') && (tmp <= 'z')) {
     eec:	f9f70693          	addi	a3,a4,-97
     ef0:	0ff6f693          	zext.b	a3,a3
     ef4:	00d56663          	bltu	a0,a3,f00 <neorv32_uart_printf+0x1e4>
      *ptr = tmp - 32;
     ef8:	fe070713          	addi	a4,a4,-32
     efc:	00e78023          	sb	a4,0(a5)
    }
    ptr++;
     f00:	00178793          	addi	a5,a5,1
  while (len > 0) {
     f04:	fec792e3          	bne	a5,a2,ee8 <neorv32_uart_printf+0x1cc>
     f08:	f6dff06f          	j	e74 <neorv32_uart_printf+0x158>
          neorv32_uart_putc(UARTx, (char)va_arg(a, int));
     f0c:	00012783          	lw	a5,0(sp)
     f10:	0007c583          	lbu	a1,0(a5)
     f14:	00478713          	addi	a4,a5,4
     f18:	00e12023          	sw	a4,0(sp)
          neorv32_uart_putc(UARTx, '%');
     f1c:	00048513          	mv	a0,s1
     f20:	d79ff0ef          	jal	ra,c98 <neorv32_uart_putc>
          break;
     f24:	f59ff06f          	j	e7c <neorv32_uart_printf+0x160>
          __neorv32_uart_itoa(va_arg(a, uint32_t), string_buf);
     f28:	00012783          	lw	a5,0(sp)
     f2c:	00410593          	addi	a1,sp,4
     f30:	00478713          	addi	a4,a5,4
     f34:	0007a503          	lw	a0,0(a5)
     f38:	00e12023          	sw	a4,0(sp)
     f3c:	f0dff06f          	j	e48 <neorv32_uart_printf+0x12c>
      if (c == '\n') {
     f40:	01741863          	bne	s0,s7,f50 <neorv32_uart_printf+0x234>
        neorv32_uart_putc(UARTx, '\r');
     f44:	00d00593          	li	a1,13
     f48:	00048513          	mv	a0,s1
     f4c:	d4dff0ef          	jal	ra,c98 <neorv32_uart_putc>
      neorv32_uart_putc(UARTx, c);
     f50:	00040593          	mv	a1,s0
     f54:	00048513          	mv	a0,s1
  while ((c = *format++)) {
     f58:	00190913          	addi	s2,s2,1
      neorv32_uart_putc(UARTx, c);
     f5c:	d3dff0ef          	jal	ra,c98 <neorv32_uart_putc>
     f60:	e39ff06f          	j	d98 <neorv32_uart_printf+0x7c>

00000f64 <__divsi3>:
     f64:	06054063          	bltz	a0,fc4 <__umodsi3+0x10>
     f68:	0605c663          	bltz	a1,fd4 <__umodsi3+0x20>

00000f6c <__hidden___udivsi3>:
     f6c:	00058613          	mv	a2,a1
     f70:	00050593          	mv	a1,a0
     f74:	fff00513          	li	a0,-1
     f78:	02060c63          	beqz	a2,fb0 <__hidden___udivsi3+0x44>
     f7c:	00100693          	li	a3,1
     f80:	00b67a63          	bgeu	a2,a1,f94 <__hidden___udivsi3+0x28>
     f84:	00c05863          	blez	a2,f94 <__hidden___udivsi3+0x28>
     f88:	00161613          	slli	a2,a2,0x1
     f8c:	00169693          	slli	a3,a3,0x1
     f90:	feb66ae3          	bltu	a2,a1,f84 <__hidden___udivsi3+0x18>
     f94:	00000513          	li	a0,0
     f98:	00c5e663          	bltu	a1,a2,fa4 <__hidden___udivsi3+0x38>
     f9c:	40c585b3          	sub	a1,a1,a2
     fa0:	00d56533          	or	a0,a0,a3
     fa4:	0016d693          	srli	a3,a3,0x1
     fa8:	00165613          	srli	a2,a2,0x1
     fac:	fe0696e3          	bnez	a3,f98 <__hidden___udivsi3+0x2c>
     fb0:	00008067          	ret

00000fb4 <__umodsi3>:
     fb4:	00008293          	mv	t0,ra
     fb8:	fb5ff0ef          	jal	ra,f6c <__hidden___udivsi3>
     fbc:	00058513          	mv	a0,a1
     fc0:	00028067          	jr	t0
     fc4:	40a00533          	neg	a0,a0
     fc8:	00b04863          	bgtz	a1,fd8 <__umodsi3+0x24>
     fcc:	40b005b3          	neg	a1,a1
     fd0:	f9dff06f          	j	f6c <__hidden___udivsi3>
     fd4:	40b005b3          	neg	a1,a1
     fd8:	00008293          	mv	t0,ra
     fdc:	f91ff0ef          	jal	ra,f6c <__hidden___udivsi3>
     fe0:	40a00533          	neg	a0,a0
     fe4:	00028067          	jr	t0

00000fe8 <__modsi3>:
     fe8:	00008293          	mv	t0,ra
     fec:	0005ca63          	bltz	a1,1000 <__modsi3+0x18>
     ff0:	00054c63          	bltz	a0,1008 <__modsi3+0x20>
     ff4:	f79ff0ef          	jal	ra,f6c <__hidden___udivsi3>
     ff8:	00058513          	mv	a0,a1
     ffc:	00028067          	jr	t0
    1000:	40b005b3          	neg	a1,a1
    1004:	fe0558e3          	bgez	a0,ff4 <__modsi3+0xc>
    1008:	40a00533          	neg	a0,a0
    100c:	f61ff0ef          	jal	ra,f6c <__hidden___udivsi3>
    1010:	40b00533          	neg	a0,a1
    1014:	00028067          	jr	t0
