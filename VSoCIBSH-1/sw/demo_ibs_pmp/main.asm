
main.elf:     file format elf32-littleriscv


Disassembly of section .text:

00100000 <_vectors_start>:
  .option norvc;

  // All unimplemented interrupts/exceptions go to the default_exc_handler.
  .org 0x00
  .rept 32
  jal x0, default_exc_handler
  100000:	0e00006f          	j	1000e0 <default_exc_handler>
  100004:	0dc0006f          	j	1000e0 <default_exc_handler>
  100008:	0d80006f          	j	1000e0 <default_exc_handler>
  10000c:	0d40006f          	j	1000e0 <default_exc_handler>
  100010:	0d00006f          	j	1000e0 <default_exc_handler>
  100014:	0cc0006f          	j	1000e0 <default_exc_handler>
  100018:	0c80006f          	j	1000e0 <default_exc_handler>
  10001c:	0c40006f          	j	1000e0 <default_exc_handler>
  100020:	0c00006f          	j	1000e0 <default_exc_handler>
  100024:	0bc0006f          	j	1000e0 <default_exc_handler>
  100028:	0b80006f          	j	1000e0 <default_exc_handler>
  10002c:	0b40006f          	j	1000e0 <default_exc_handler>
  100030:	0b00006f          	j	1000e0 <default_exc_handler>
  100034:	0ac0006f          	j	1000e0 <default_exc_handler>
  100038:	0a80006f          	j	1000e0 <default_exc_handler>
  10003c:	0a40006f          	j	1000e0 <default_exc_handler>
  100040:	0a00006f          	j	1000e0 <default_exc_handler>
  100044:	09c0006f          	j	1000e0 <default_exc_handler>
  100048:	0980006f          	j	1000e0 <default_exc_handler>
  10004c:	0940006f          	j	1000e0 <default_exc_handler>
  100050:	0900006f          	j	1000e0 <default_exc_handler>
  100054:	08c0006f          	j	1000e0 <default_exc_handler>
  100058:	0880006f          	j	1000e0 <default_exc_handler>
  10005c:	0840006f          	j	1000e0 <default_exc_handler>
  100060:	0800006f          	j	1000e0 <default_exc_handler>
  100064:	07c0006f          	j	1000e0 <default_exc_handler>
  100068:	0780006f          	j	1000e0 <default_exc_handler>
  10006c:	0740006f          	j	1000e0 <default_exc_handler>
  100070:	0700006f          	j	1000e0 <default_exc_handler>
  100074:	06c0006f          	j	1000e0 <default_exc_handler>
  100078:	0680006f          	j	1000e0 <default_exc_handler>
  10007c:	0640006f          	j	1000e0 <default_exc_handler>
  .endr

  // reset vector
  .org 0x80
  jal x0, reset_handler
  100080:	0640006f          	j	1000e4 <reset_handler>

00100084 <_vectors_end>:

.set ALLOW_ADDRESS, 0x001FFFFF //address allowed//0x0000FFFF would trigger a store access fault exception on line sw a1, 0(a0)
main:

    //allow pmp
    li t1, ALLOW_ADDRESS     // Give user access to whole of imem and dmem. 
  100084:	00200337          	lui	t1,0x200
  100088:	fff30313          	addi	t1,t1,-1 # 1fffff <ALLOW_ADDRESS>
    srli t1, t1, 2        // Shift right logical by 2 bits (divide by 4)
  10008c:	00235313          	srli	t1,t1,0x2
    csrw pmpaddr0, t1     // Write the value of t1 to the PMP address register pmpaddr0
  100090:	3b031073          	csrw	pmpaddr0,t1
    li t0, 0x0708080F     // Load immediate value 0x0707070F into register t0
  100094:	070812b7          	lui	t0,0x7081
  100098:	80f28293          	addi	t0,t0,-2033 # 708080f <ALLOW_ADDRESS+0x6e80810>
    csrw pmpcfg0, t0 
  10009c:	3a029073          	csrw	pmpcfg0,t0

//	li	a5,0x20088
    li a5, 0x88
  1000a0:	08800793          	li	a5,136
	csrw	mstatus,a5
  1000a4:	30079073          	csrw	mstatus,a5
	jal 	ra, goto_user_mode
  1000a8:	010000ef          	jal	ra,1000b8 <goto_user_mode>
	add 	a5, a5, 1    //should execute fine	
  1000ac:	00178793          	addi	a5,a5,1
    csrw 	mstatus, a5 //should raise IIE
  1000b0:	30079073          	csrw	mstatus,a5
	add 	a5, a5, 1
  1000b4:	00178793          	addi	a5,a5,1

001000b8 <goto_user_mode>:

goto_user_mode:
	csrw	mepc,ra
  1000b8:	34109073          	csrw	mepc,ra
	lui	ra,0x2
  1000bc:	000020b7          	lui	ra,0x2
	addi	ra,ra,-2048
  1000c0:	80008093          	addi	ra,ra,-2048 # 1800 <_min_stack+0x800>
	csrc	mstatus,ra
  1000c4:	3000b073          	csrc	mstatus,ra
    li      t1, (1<<17)
  1000c8:	00020337          	lui	t1,0x20
    csrr    t0, mstatus
  1000cc:	300022f3          	csrr	t0,mstatus
    or      t0, t0, t1
  1000d0:	0062e2b3          	or	t0,t0,t1
    csrw    mstatus, t0
  1000d4:	30029073          	csrw	mstatus,t0
	mret
  1000d8:	30200073          	mret
	add 	a5, a5, 1
  1000dc:	00178793          	addi	a5,a5,1

001000e0 <default_exc_handler>:
  jal x0, simple_exc_handler
  1000e0:	1b40006f          	j	100294 <simple_exc_handler>

001000e4 <reset_handler>:
  mv  x1, x0
  1000e4:	00000093          	li	ra,0
  mv  x2, x1
  1000e8:	00008113          	mv	sp,ra
  mv  x3, x1
  1000ec:	00008193          	mv	gp,ra
  mv  x4, x1
  1000f0:	00008213          	mv	tp,ra
  mv  x5, x1
  1000f4:	00008293          	mv	t0,ra
  mv  x6, x1
  1000f8:	00008313          	mv	t1,ra
  mv  x7, x1
  1000fc:	00008393          	mv	t2,ra
  mv  x8, x1
  100100:	00008413          	mv	s0,ra
  mv  x9, x1
  100104:	00008493          	mv	s1,ra
  mv x10, x1
  100108:	00008513          	mv	a0,ra
  mv x11, x1
  10010c:	00008593          	mv	a1,ra
  mv x12, x1
  100110:	00008613          	mv	a2,ra
  mv x13, x1
  100114:	00008693          	mv	a3,ra
  mv x14, x1
  100118:	00008713          	mv	a4,ra
  mv x15, x1
  10011c:	00008793          	mv	a5,ra
  mv x16, x1
  100120:	00008813          	mv	a6,ra
  mv x17, x1
  100124:	00008893          	mv	a7,ra
  mv x18, x1
  100128:	00008913          	mv	s2,ra
  mv x19, x1
  10012c:	00008993          	mv	s3,ra
  mv x20, x1
  100130:	00008a13          	mv	s4,ra
  mv x21, x1
  100134:	00008a93          	mv	s5,ra
  mv x22, x1
  100138:	00008b13          	mv	s6,ra
  mv x23, x1
  10013c:	00008b93          	mv	s7,ra
  mv x24, x1
  100140:	00008c13          	mv	s8,ra
  mv x25, x1
  100144:	00008c93          	mv	s9,ra
  mv x26, x1
  100148:	00008d13          	mv	s10,ra
  mv x27, x1
  10014c:	00008d93          	mv	s11,ra
  mv x28, x1
  100150:	00008e13          	mv	t3,ra
  mv x29, x1
  100154:	00008e93          	mv	t4,ra
  mv x30, x1
  100158:	00008f13          	mv	t5,ra
  mv x31, x1
  10015c:	00008f93          	mv	t6,ra
  la   x2, _stack_start
  100160:	00010117          	auipc	sp,0x10
  100164:	ea010113          	addi	sp,sp,-352 # 110000 <_stack_start>

00100168 <_start>:
  la x26, _bss_start
  100168:	00000d17          	auipc	s10,0x0
  10016c:	1d8d0d13          	addi	s10,s10,472 # 100340 <_bss_end>
  la x27, _bss_end
  100170:	00000d97          	auipc	s11,0x0
  100174:	1d0d8d93          	addi	s11,s11,464 # 100340 <_bss_end>
  bge x26, x27, zero_loop_end
  100178:	01bd5863          	bge	s10,s11,100188 <main_entry>

0010017c <zero_loop>:
  sw x0, 0(x26)
  10017c:	000d2023          	sw	zero,0(s10)
  addi x26, x26, 4
  100180:	004d0d13          	addi	s10,s10,4
  ble x26, x27, zero_loop
  100184:	ffaddce3          	bge	s11,s10,10017c <zero_loop>

00100188 <main_entry>:
  addi x10, x0, 0
  100188:	00000513          	li	a0,0
  addi x11, x0, 0
  10018c:	00000593          	li	a1,0
  jal x1, main
  100190:	ef5ff0ef          	jal	ra,100084 <_vectors_end>
  li x5, SIM_CTRL_BASE + SIM_CTRL_CTRL
  100194:	000202b7          	lui	t0,0x20
  100198:	00828293          	addi	t0,t0,8 # 20008 <_stack_len+0x1e008>
  li x6, 1
  10019c:	00100313          	li	t1,1
  sw x6, 0(x5)
  1001a0:	0062a023          	sw	t1,0(t0)

001001a4 <sleep_loop>:
  wfi
  1001a4:	10500073          	wfi
  j sleep_loop
  1001a8:	ffdff06f          	j	1001a4 <sleep_loop>

001001ac <uart_out>:

  return res;
}

void uart_out(uart_t uart, char c) {
  while (DEV_READ(uart + UART_STATUS_REG) & UART_STATUS_TX_FULL)
  1001ac:	00852783          	lw	a5,8(a0)
  1001b0:	0027f793          	andi	a5,a5,2
  1001b4:	fe079ce3          	bnez	a5,1001ac <uart_out>
    ;

  DEV_WRITE(uart + UART_TX_REG, c);
  1001b8:	00b52223          	sw	a1,4(a0)
}
  1001bc:	00008067          	ret

001001c0 <putchar>:
#include "demo_system.h"

#include "dev_access.h"
#include "uart.h"

int putchar(int c) {
  1001c0:	ff010113          	addi	sp,sp,-16
  1001c4:	00812423          	sw	s0,8(sp)
  1001c8:	00112623          	sw	ra,12(sp)
#ifdef SIM_CTRL_OUTPUT
  DEV_WRITE(SIM_CTRL_BASE + SIM_CTRL_OUT, c);
#else
  if (c == '\n') {
  1001cc:	00a00793          	li	a5,10
int putchar(int c) {
  1001d0:	00050413          	mv	s0,a0
  if (c == '\n') {
  1001d4:	00f51863          	bne	a0,a5,1001e4 <putchar+0x24>
    uart_out(DEFAULT_UART, '\r');
  1001d8:	00d00593          	li	a1,13
  1001dc:	80001537          	lui	a0,0x80001
  1001e0:	fcdff0ef          	jal	ra,1001ac <uart_out>
  }

  uart_out(DEFAULT_UART, c);
  1001e4:	0ff47593          	zext.b	a1,s0
  1001e8:	80001537          	lui	a0,0x80001
  1001ec:	fc1ff0ef          	jal	ra,1001ac <uart_out>
#endif

  return c;
}
  1001f0:	00c12083          	lw	ra,12(sp)
  1001f4:	00040513          	mv	a0,s0
  1001f8:	00812403          	lw	s0,8(sp)
  1001fc:	01010113          	addi	sp,sp,16
  100200:	00008067          	ret

00100204 <puts>:

int getchar(void) { return uart_in(DEFAULT_UART); }

int puts(const char* str) {
  100204:	ff010113          	addi	sp,sp,-16
  100208:	00812423          	sw	s0,8(sp)
  10020c:	00112623          	sw	ra,12(sp)
  100210:	00050413          	mv	s0,a0
  while (*str) {
  100214:	00044503          	lbu	a0,0(s0)
  100218:	00051a63          	bnez	a0,10022c <puts+0x28>
    putchar(*str++);
  }

  return 0;
}
  10021c:	00c12083          	lw	ra,12(sp)
  100220:	00812403          	lw	s0,8(sp)
  100224:	01010113          	addi	sp,sp,16
  100228:	00008067          	ret
    putchar(*str++);
  10022c:	00140413          	addi	s0,s0,1
  100230:	f91ff0ef          	jal	ra,1001c0 <putchar>
  100234:	fe1ff06f          	j	100214 <puts+0x10>

00100238 <puthex>:

void puthex(uint32_t h) {
  100238:	ff010113          	addi	sp,sp,-16
  10023c:	00812423          	sw	s0,8(sp)
  100240:	00912223          	sw	s1,4(sp)
  100244:	01212023          	sw	s2,0(sp)
  100248:	00112623          	sw	ra,12(sp)
  10024c:	00050413          	mv	s0,a0
  100250:	00800493          	li	s1,8
  // Iterate through h taking top 4 bits each time and outputting ASCII of hex
  // digit for those 4 bits
  for (int i = 0; i < 8; i++) {
    cur_digit = h >> 28;

    if (cur_digit < 10)
  100254:	00900913          	li	s2,9
    cur_digit = h >> 28;
  100258:	01c45513          	srli	a0,s0,0x1c
    if (cur_digit < 10)
  10025c:	02a96863          	bltu	s2,a0,10028c <puthex+0x54>
      putchar('0' + cur_digit);
  100260:	03050513          	addi	a0,a0,48 # 80001030 <ALLOW_ADDRESS+0x7fe01031>
  for (int i = 0; i < 8; i++) {
  100264:	fff48493          	addi	s1,s1,-1
    else
      putchar('A' - 10 + cur_digit);
  100268:	f59ff0ef          	jal	ra,1001c0 <putchar>

    h <<= 4;
  10026c:	00441413          	slli	s0,s0,0x4
  for (int i = 0; i < 8; i++) {
  100270:	fe0494e3          	bnez	s1,100258 <puthex+0x20>
  }
}
  100274:	00c12083          	lw	ra,12(sp)
  100278:	00812403          	lw	s0,8(sp)
  10027c:	00412483          	lw	s1,4(sp)
  100280:	00012903          	lw	s2,0(sp)
  100284:	01010113          	addi	sp,sp,16
  100288:	00008067          	ret
      putchar('A' - 10 + cur_digit);
  10028c:	03750513          	addi	a0,a0,55
  100290:	fd5ff06f          	j	100264 <puthex+0x2c>

00100294 <simple_exc_handler>:
  } else {
    asm volatile("csrc mstatus, %0\n" : : "r"(1 << 3));
  }
}

void simple_exc_handler(void) {
  100294:	ff010113          	addi	sp,sp,-16
  puts("EXCEPTION!!!\n");
  100298:	00000517          	auipc	a0,0x0
  10029c:	06450513          	addi	a0,a0,100 # 1002fc <simple_exc_handler+0x68>
void simple_exc_handler(void) {
  1002a0:	00112623          	sw	ra,12(sp)
  puts("EXCEPTION!!!\n");
  1002a4:	f61ff0ef          	jal	ra,100204 <puts>
  puts("============\n");
  1002a8:	00000517          	auipc	a0,0x0
  1002ac:	06450513          	addi	a0,a0,100 # 10030c <simple_exc_handler+0x78>
  1002b0:	f55ff0ef          	jal	ra,100204 <puts>
  puts("MEPC:   0x");
  1002b4:	00000517          	auipc	a0,0x0
  1002b8:	06850513          	addi	a0,a0,104 # 10031c <simple_exc_handler+0x88>
  1002bc:	f49ff0ef          	jal	ra,100204 <puts>
  __asm__ volatile("csrr %0, mepc;" : "=r"(result));
  1002c0:	34102573          	csrr	a0,mepc
  puthex(get_mepc());
  1002c4:	f75ff0ef          	jal	ra,100238 <puthex>
  puts("\nMCAUSE: 0x");
  1002c8:	00000517          	auipc	a0,0x0
  1002cc:	06050513          	addi	a0,a0,96 # 100328 <simple_exc_handler+0x94>
  1002d0:	f35ff0ef          	jal	ra,100204 <puts>
  __asm__ volatile("csrr %0, mcause;" : "=r"(result));
  1002d4:	34202573          	csrr	a0,mcause
  puthex(get_mcause());
  1002d8:	f61ff0ef          	jal	ra,100238 <puthex>
  puts("\nMTVAL:  0x");
  1002dc:	00000517          	auipc	a0,0x0
  1002e0:	05850513          	addi	a0,a0,88 # 100334 <simple_exc_handler+0xa0>
  1002e4:	f21ff0ef          	jal	ra,100204 <puts>
  __asm__ volatile("csrr %0, mtval;" : "=r"(result));
  1002e8:	34302573          	csrr	a0,mtval
  puthex(get_mtval());
  1002ec:	f4dff0ef          	jal	ra,100238 <puthex>
  putchar('\n');
  1002f0:	00a00513          	li	a0,10
  1002f4:	ecdff0ef          	jal	ra,1001c0 <putchar>

  while (1)
  1002f8:	0000006f          	j	1002f8 <simple_exc_handler+0x64>
