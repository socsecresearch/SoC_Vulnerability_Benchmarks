
my_main.elf:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <__crt0_entry>:
       0:	30005073          	csrwi	mstatus,0

00000004 <__crt0_cpu_csr_init>:
       4:	30401073          	csrw	mie,zero
       8:	00000097          	auipc	ra,0x0
       c:	13408093          	addi	ra,ra,308 # 13c <__crt0_trap_handler>
      10:	30509073          	csrw	mtvec,ra

00000014 <__crt0_pointer_init>:
      14:	80002117          	auipc	sp,0x80002
      18:	fe810113          	addi	sp,sp,-24 # 80001ffc <__crt0_stack_begin+0x0>
      1c:	80000197          	auipc	gp,0x80000
      20:	7e418193          	addi	gp,gp,2020 # 80000800 <__crt0_stack_begin+0xffffe804>

00000024 <__crt0_reg_file_init>:
      24:	00000213          	li	tp,0
      28:	00000293          	li	t0,0
      2c:	00000313          	li	t1,0
      30:	00000393          	li	t2,0
      34:	00000413          	li	s0,0
      38:	00000493          	li	s1,0
      3c:	00000813          	li	a6,0
      40:	00000893          	li	a7,0
      44:	00000913          	li	s2,0
      48:	00000993          	li	s3,0
      4c:	00000a13          	li	s4,0
      50:	00000a93          	li	s5,0
      54:	00000b13          	li	s6,0
      58:	00000b93          	li	s7,0
      5c:	00000c13          	li	s8,0
      60:	00000c93          	li	s9,0
      64:	00000d13          	li	s10,0
      68:	00000d93          	li	s11,0
      6c:	00000e13          	li	t3,0
      70:	00000e93          	li	t4,0
      74:	00000f13          	li	t5,0
      78:	00000f93          	li	t6,0

0000007c <__crt0_copy_data>:
      7c:	00001597          	auipc	a1,0x1
      80:	48858593          	addi	a1,a1,1160 # 1504 <__RODATA_END__>
      84:	80000617          	auipc	a2,0x80000
      88:	f7c60613          	addi	a2,a2,-132 # 80000000 <__crt0_stack_begin+0xffffe004>
      8c:	80000697          	auipc	a3,0x80000
      90:	f7468693          	addi	a3,a3,-140 # 80000000 <__crt0_stack_begin+0xffffe004>
      94:	00c58e63          	beq	a1,a2,b0 <__crt0_clear_bss>

00000098 <__crt0_copy_data_loop>:
      98:	00d65c63          	bge	a2,a3,b0 <__crt0_clear_bss>
      9c:	0005a703          	lw	a4,0(a1)
      a0:	00e62023          	sw	a4,0(a2)
      a4:	00458593          	addi	a1,a1,4
      a8:	00460613          	addi	a2,a2,4
      ac:	fedff06f          	j	98 <__crt0_copy_data_loop>

000000b0 <__crt0_clear_bss>:
      b0:	80000717          	auipc	a4,0x80000
      b4:	f5070713          	addi	a4,a4,-176 # 80000000 <__crt0_stack_begin+0xffffe004>
      b8:	89418793          	addi	a5,gp,-1900 # 80000094 <__BSS_END__>

000000bc <__crt0_clear_bss_loop>:
      bc:	00f75863          	bge	a4,a5,cc <__crt0_call_constructors>
      c0:	00072023          	sw	zero,0(a4)
      c4:	00470713          	addi	a4,a4,4
      c8:	ff5ff06f          	j	bc <__crt0_clear_bss_loop>

000000cc <__crt0_call_constructors>:
      cc:	00001417          	auipc	s0,0x1
      d0:	f4840413          	addi	s0,s0,-184 # 1014 <__etext>
      d4:	00001497          	auipc	s1,0x1
      d8:	f4048493          	addi	s1,s1,-192 # 1014 <__etext>

000000dc <__crt0_call_constructors_loop>:
      dc:	00945a63          	bge	s0,s1,f0 <__crt0_call_constructors_loop_end>
      e0:	00042083          	lw	ra,0(s0)
      e4:	000080e7          	jalr	ra
      e8:	00440413          	addi	s0,s0,4
      ec:	ff1ff06f          	j	dc <__crt0_call_constructors_loop>

000000f0 <__crt0_call_constructors_loop_end>:
      f0:	00000513          	li	a0,0
      f4:	00000593          	li	a1,0
      f8:	090000ef          	jal	ra,188 <main>

000000fc <__crt0_main_exit>:
      fc:	30401073          	csrw	mie,zero
     100:	34051073          	csrw	mscratch,a0

00000104 <__crt0_call_destructors>:
     104:	00001417          	auipc	s0,0x1
     108:	f1040413          	addi	s0,s0,-240 # 1014 <__etext>
     10c:	00001497          	auipc	s1,0x1
     110:	f0848493          	addi	s1,s1,-248 # 1014 <__etext>

00000114 <__crt0_call_destructors_loop>:
     114:	00945a63          	bge	s0,s1,128 <__crt0_call_destructors_loop_end>
     118:	00042083          	lw	ra,0(s0)
     11c:	000080e7          	jalr	ra
     120:	00440413          	addi	s0,s0,4
     124:	ff1ff06f          	j	114 <__crt0_call_destructors_loop>

00000128 <__crt0_call_destructors_loop_end>:
     128:	00000093          	li	ra,0
     12c:	00008463          	beqz	ra,134 <__crt0_main_aftermath_end>
     130:	000080e7          	jalr	ra

00000134 <__crt0_main_aftermath_end>:
     134:	10500073          	wfi
     138:	ffdff06f          	j	134 <__crt0_main_aftermath_end>

0000013c <__crt0_trap_handler>:
     13c:	ff810113          	addi	sp,sp,-8
     140:	00812023          	sw	s0,0(sp)
     144:	00912223          	sw	s1,4(sp)
     148:	34202473          	csrr	s0,mcause
     14c:	02044663          	bltz	s0,178 <__crt0_trap_handler_end>
     150:	34102473          	csrr	s0,mepc
     154:	00041483          	lh	s1,0(s0)
     158:	0034f493          	andi	s1,s1,3
     15c:	00240413          	addi	s0,s0,2
     160:	34141073          	csrw	mepc,s0
     164:	00300413          	li	s0,3
     168:	00941863          	bne	s0,s1,178 <__crt0_trap_handler_end>
     16c:	34102473          	csrr	s0,mepc
     170:	00240413          	addi	s0,s0,2
     174:	34141073          	csrw	mepc,s0

00000178 <__crt0_trap_handler_end>:
     178:	00012403          	lw	s0,0(sp)
     17c:	00412483          	lw	s1,4(sp)
     180:	00810113          	addi	sp,sp,8
     184:	30200073          	mret

00000188 <main>:
 *
 * @note This program requires UART0 and the DMA controller to be synthesized.
 *
 * @return Irrelevant.
 **************************************************************************/
int main() {
     188:	fe010113          	addi	sp,sp,-32
     18c:	00112e23          	sw	ra,28(sp)
     190:	00812c23          	sw	s0,24(sp)
     194:	00912a23          	sw	s1,20(sp)
     198:	01212823          	sw	s2,16(sp)
     19c:	01312623          	sw	s3,12(sp)
     1a0:	01412423          	sw	s4,8(sp)

  uint32_t cmd;
  int rc;

  // setup NEORV32 runtime environment
  neorv32_rte_setup();
     1a4:	0c5000ef          	jal	ra,a68 <neorv32_rte_setup>

  // setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);
     1a8:	fffff437          	lui	s0,0xfffff
     1ac:	000055b7          	lui	a1,0x5
     1b0:	00000613          	li	a2,0
     1b4:	b0058593          	addi	a1,a1,-1280 # 4b00 <__neorv32_ram_size+0x2b00>
     1b8:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     1bc:	23d000ef          	jal	ra,bf8 <neorv32_uart_setup>

  // intro
  neorv32_uart0_printf("\n<<< DMA Controller Demo Program >>>\n\n");
     1c0:	000015b7          	lui	a1,0x1
     1c4:	0b058593          	addi	a1,a1,176 # 10b0 <__etext+0x9c>
     1c8:	50040513          	addi	a0,s0,1280
     1cc:	34d000ef          	jal	ra,d18 <neorv32_uart_printf>

  // check if DMA controller is implemented at all
  if (neorv32_dma_available() == 0) {
     1d0:	2b4000ef          	jal	ra,484 <neorv32_dma_available>
     1d4:	02051c63          	bnez	a0,20c <main+0x84>
    neorv32_uart0_printf("ERROR! DMA controller not implemented!\n");
     1d8:	000015b7          	lui	a1,0x1
     1dc:	50040513          	addi	a0,s0,1280
     1e0:	0d858593          	addi	a1,a1,216 # 10d8 <__etext+0xc4>
     1e4:	335000ef          	jal	ra,d18 <neorv32_uart_printf>
    return 1;
     1e8:	00100513          	li	a0,1
  }

*/
  neorv32_uart0_printf("\nProgram completed.\n");
  return 0;
}
     1ec:	01c12083          	lw	ra,28(sp)
     1f0:	01812403          	lw	s0,24(sp)
     1f4:	01412483          	lw	s1,20(sp)
     1f8:	01012903          	lw	s2,16(sp)
     1fc:	00c12983          	lw	s3,12(sp)
     200:	00812a03          	lw	s4,8(sp)
     204:	02010113          	addi	sp,sp,32
     208:	00008067          	ret
  neorv32_uart0_printf("Source test data:      %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_src[0]));
     20c:	800009b7          	lui	s3,0x80000
     210:	000015b7          	lui	a1,0x1
     214:	01098693          	addi	a3,s3,16 # 80000010 <__crt0_stack_begin+0xffffe014>
     218:	50040513          	addi	a0,s0,1280
     21c:	01000613          	li	a2,16
     220:	10058593          	addi	a1,a1,256 # 1100 <__etext+0xec>
     224:	2f5000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("Destination test data: %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_dst[0]));
     228:	80000a37          	lui	s4,0x80000
     22c:	000015b7          	lui	a1,0x1
     230:	000a0693          	mv	a3,s4
     234:	01000613          	li	a2,16
     238:	50040513          	addi	a0,s0,1280
     23c:	12858593          	addi	a1,a1,296 # 1128 <__etext+0x114>
     240:	2d9000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_rte_handler_install(DMA_RTE_ID, dma_firq_handler);
     244:	39400593          	li	a1,916
     248:	01700513          	li	a0,23
     24c:	7c0000ef          	jal	ra,a0c <neorv32_rte_handler_install>
  neorv32_dma_enable();
     250:	244000ef          	jal	ra,494 <neorv32_dma_enable>
  dma_src[0] = 0x66778899UL;
     254:	667797b7          	lui	a5,0x66779
  neorv32_uart0_printf("Source test data:      %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_src[0]));
     258:	01098493          	addi	s1,s3,16
  dma_src[0] = 0x66778899UL;
     25c:	89978793          	addi	a5,a5,-1895 # 66778899 <__neorv32_ram_size+0x66776899>
     260:	00f4a023          	sw	a5,0(s1)
  dma_src[1] = 0x22334455UL;
     264:	223347b7          	lui	a5,0x22334
     268:	45578793          	addi	a5,a5,1109 # 22334455 <__neorv32_ram_size+0x22332455>
     26c:	00f4a223          	sw	a5,4(s1)
  dma_src[2] = 0xaabbccddUL;
     270:	aabbd7b7          	lui	a5,0xaabbd
     274:	cdd78793          	addi	a5,a5,-803 # aabbccdd <__crt0_stack_begin+0x2abbace1>
     278:	00f4a423          	sw	a5,8(s1)
  dma_src[3] = 0x0011eeffUL;
     27c:	0011f7b7          	lui	a5,0x11f
     280:	eff78793          	addi	a5,a5,-257 # 11eeff <__neorv32_ram_size+0x11ceff>
  neorv32_uart0_printf("Destination test data: %u bytes @ 0x%x\n", (uint32_t)(sizeof(dma_src)), (uint32_t)(&dma_dst[0]));
     284:	000a0913          	mv	s2,s4
  dma_src[3] = 0x0011eeffUL;
     288:	00f4a623          	sw	a5,12(s1)
  dma_dst[0] = 0;
     28c:	00092023          	sw	zero,0(s2)
  dma_dst[1] = 0;
     290:	00092223          	sw	zero,4(s2)
  dma_dst[2] = 0;
     294:	00092423          	sw	zero,8(s2)
  dma_dst[3] = 0;
     298:	00092623          	sw	zero,12(s2)
  asm volatile ("fence"); // make sure main memory is sync with d-cache
     29c:	0ff0000f          	fence
  neorv32_uart0_printf("\nExample 1: Manual byte-to-byte block transfer with Endianness conversion using busy wait.\n");
     2a0:	000015b7          	lui	a1,0x1
     2a4:	50040513          	addi	a0,s0,1280
     2a8:	15058593          	addi	a1,a1,336 # 1150 <__etext+0x13c>
     2ac:	26d000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_dma_transfer((uint32_t)(&dma_src[0]), // source array base address - byte-aligned!
     2b0:	01098513          	addi	a0,s3,16
     2b4:	e00006b7          	lui	a3,0xe0000
     2b8:	01000613          	li	a2,16
     2bc:	000a0593          	mv	a1,s4
     2c0:	1e8000ef          	jal	ra,4a8 <neorv32_dma_transfer>
  neorv32_uart0_printf("Waiting for DMA... ");
     2c4:	000019b7          	lui	s3,0x1
     2c8:	50040513          	addi	a0,s0,1280
     2cc:	1ac98593          	addi	a1,s3,428 # 11ac <__etext+0x198>
     2d0:	249000ef          	jal	ra,d18 <neorv32_uart_printf>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     2d4:	00100413          	li	s0,1
    rc = neorv32_dma_status();
     2d8:	208000ef          	jal	ra,4e0 <neorv32_dma_status>
    if (rc == DMA_STATUS_IDLE) {
     2dc:	08051863          	bnez	a0,36c <main+0x1e4>
      neorv32_uart0_printf("Transfer done.\n");
     2e0:	000015b7          	lui	a1,0x1
     2e4:	1c058593          	addi	a1,a1,448 # 11c0 <__etext+0x1ac>
      neorv32_uart0_printf("Transfer failed!\n");
     2e8:	fffff537          	lui	a0,0xfffff
     2ec:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     2f0:	229000ef          	jal	ra,d18 <neorv32_uart_printf>
  show_arrays();
     2f4:	0bc000ef          	jal	ra,3b0 <show_arrays>
  neorv32_uart0_printf("\nExample 2: Manual word-to-word one-to-many transfer using busy wait.\n");
     2f8:	fffff437          	lui	s0,0xfffff
     2fc:	000015b7          	lui	a1,0x1
     300:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     304:	1e458593          	addi	a1,a1,484 # 11e4 <__etext+0x1d0>
     308:	211000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_dma_transfer((uint32_t)(&dma_src[0]), // source array base address - word-aligned!
     30c:	580006b7          	lui	a3,0x58000
     310:	00400613          	li	a2,4
     314:	00090593          	mv	a1,s2
     318:	00048513          	mv	a0,s1
     31c:	18c000ef          	jal	ra,4a8 <neorv32_dma_transfer>
  neorv32_uart0_printf("Waiting for DMA... ");
     320:	50040513          	addi	a0,s0,1280
     324:	1ac98593          	addi	a1,s3,428
     328:	1f1000ef          	jal	ra,d18 <neorv32_uart_printf>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     32c:	00100413          	li	s0,1
    rc = neorv32_dma_status();
     330:	1b0000ef          	jal	ra,4e0 <neorv32_dma_status>
    if (rc == DMA_STATUS_IDLE) {
     334:	04051663          	bnez	a0,380 <main+0x1f8>
      neorv32_uart0_printf("Transfer done.\n");
     338:	000015b7          	lui	a1,0x1
     33c:	1c058593          	addi	a1,a1,448 # 11c0 <__etext+0x1ac>
      neorv32_uart0_printf("Transfer failed!\n");
     340:	fffff537          	lui	a0,0xfffff
     344:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     348:	1d1000ef          	jal	ra,d18 <neorv32_uart_printf>
  show_arrays();
     34c:	064000ef          	jal	ra,3b0 <show_arrays>
  neorv32_uart0_printf("\nProgram completed.\n");
     350:	000015b7          	lui	a1,0x1
     354:	fffff537          	lui	a0,0xfffff
     358:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     35c:	22c58593          	addi	a1,a1,556 # 122c <__etext+0x218>
     360:	1b9000ef          	jal	ra,d18 <neorv32_uart_printf>
  return 0;
     364:	00000513          	li	a0,0
     368:	e85ff06f          	j	1ec <main+0x64>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     36c:	00250513          	addi	a0,a0,2
     370:	f6a464e3          	bltu	s0,a0,2d8 <main+0x150>
      neorv32_uart0_printf("Transfer failed!\n");
     374:	000015b7          	lui	a1,0x1
     378:	1d058593          	addi	a1,a1,464 # 11d0 <__etext+0x1bc>
     37c:	f6dff06f          	j	2e8 <main+0x160>
    else if ((rc == DMA_STATUS_ERR_RD) || (rc == DMA_STATUS_ERR_WR)) {
     380:	00250513          	addi	a0,a0,2
     384:	faa466e3          	bltu	s0,a0,330 <main+0x1a8>
      neorv32_uart0_printf("Transfer failed!\n");
     388:	000015b7          	lui	a1,0x1
     38c:	1d058593          	addi	a1,a1,464 # 11d0 <__etext+0x1bc>
     390:	fb1ff06f          	j	340 <main+0x1b8>

00000394 <dma_firq_handler>:
 **************************************************************************/
inline void __attribute__ ((always_inline)) neorv32_cpu_csr_clr(const int csr_id, uint32_t mask) {

  uint32_t csr_data = mask;

  asm volatile ("csrc %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     394:	040007b7          	lui	a5,0x4000
     398:	3447b073          	csrc	mip,a5
 * @warning This function has to be of type "void xyz(void)" and must not use any interrupt attributes!
 **************************************************************************/
void dma_firq_handler(void) {

  neorv32_cpu_csr_clr(CSR_MIP, 1 << DMA_FIRQ_PENDING); // clear/ack pending FIRQ
  neorv32_uart0_printf("<<DMA interrupt>>\n");
     39c:	000015b7          	lui	a1,0x1
     3a0:	fffff537          	lui	a0,0xfffff
     3a4:	01458593          	addi	a1,a1,20 # 1014 <__etext>
     3a8:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     3ac:	16d0006f          	j	d18 <neorv32_uart_printf>

000003b0 <show_arrays>:
void show_arrays(void) {
     3b0:	fe010113          	addi	sp,sp,-32
     3b4:	00112e23          	sw	ra,28(sp)
     3b8:	00812c23          	sw	s0,24(sp)
     3bc:	00912a23          	sw	s1,20(sp)
     3c0:	01212823          	sw	s2,16(sp)
     3c4:	01312623          	sw	s3,12(sp)
  asm volatile ("fence"); // make sure main memory is sync with d-cache
     3c8:	0ff0000f          	fence
  neorv32_uart0_printf("---------------------------\n");
     3cc:	fffff437          	lui	s0,0xfffff
     3d0:	000019b7          	lui	s3,0x1
     3d4:	02898593          	addi	a1,s3,40 # 1028 <__etext+0x14>
     3d8:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     3dc:	13d000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("     SRC         DST\n");
     3e0:	000015b7          	lui	a1,0x1
     3e4:	50040513          	addi	a0,s0,1280
     3e8:	04858593          	addi	a1,a1,72 # 1048 <__etext+0x34>
  neorv32_uart0_printf("[0]  0x%x  0x%x\n", dma_src[0], dma_dst[0]);
     3ec:	80000937          	lui	s2,0x80000
     3f0:	800004b7          	lui	s1,0x80000
  neorv32_uart0_printf("     SRC         DST\n");
     3f4:	125000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("[0]  0x%x  0x%x\n", dma_src[0], dma_dst[0]);
     3f8:	01090913          	addi	s2,s2,16 # 80000010 <__crt0_stack_begin+0xffffe014>
     3fc:	00048493          	mv	s1,s1
     400:	00092603          	lw	a2,0(s2)
     404:	0004a683          	lw	a3,0(s1) # 80000000 <__crt0_stack_begin+0xffffe004>
     408:	000015b7          	lui	a1,0x1
     40c:	50040513          	addi	a0,s0,1280
     410:	06058593          	addi	a1,a1,96 # 1060 <__etext+0x4c>
     414:	105000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("[1]  0x%x  0x%x\n", dma_src[1], dma_dst[1]);
     418:	00492603          	lw	a2,4(s2)
     41c:	0044a683          	lw	a3,4(s1)
     420:	000015b7          	lui	a1,0x1
     424:	50040513          	addi	a0,s0,1280
     428:	07458593          	addi	a1,a1,116 # 1074 <__etext+0x60>
     42c:	0ed000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("[2]  0x%x  0x%x\n", dma_src[2], dma_dst[2]);
     430:	00892603          	lw	a2,8(s2)
     434:	0084a683          	lw	a3,8(s1)
     438:	000015b7          	lui	a1,0x1
     43c:	50040513          	addi	a0,s0,1280
     440:	08858593          	addi	a1,a1,136 # 1088 <__etext+0x74>
     444:	0d5000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("[3]  0x%x  0x%x\n", dma_src[3], dma_dst[3]);
     448:	00c92603          	lw	a2,12(s2)
     44c:	00c4a683          	lw	a3,12(s1)
     450:	000015b7          	lui	a1,0x1
     454:	50040513          	addi	a0,s0,1280
     458:	09c58593          	addi	a1,a1,156 # 109c <__etext+0x88>
     45c:	0bd000ef          	jal	ra,d18 <neorv32_uart_printf>
  neorv32_uart0_printf("---------------------------\n");
     460:	50040513          	addi	a0,s0,1280
}
     464:	01812403          	lw	s0,24(sp)
     468:	01c12083          	lw	ra,28(sp)
     46c:	01412483          	lw	s1,20(sp)
     470:	01012903          	lw	s2,16(sp)
  neorv32_uart0_printf("---------------------------\n");
     474:	02898593          	addi	a1,s3,40
}
     478:	00c12983          	lw	s3,12(sp)
     47c:	02010113          	addi	sp,sp,32
  neorv32_uart0_printf("---------------------------\n");
     480:	0990006f          	j	d18 <neorv32_uart_printf>

00000484 <neorv32_dma_available>:
 *
 * @return 0 if DMA was not synthesized, 1 if DMA is available.
 **************************************************************************/
int neorv32_dma_available(void) {

  if (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_DMA)) {
     484:	e0802503          	lw	a0,-504(zero) # fffffe08 <__crt0_stack_begin+0x7fffde0c>
     488:	00e55513          	srli	a0,a0,0xe
    return 1;
  }
  else {
    return 0;
  }
}
     48c:	00157513          	andi	a0,a0,1
     490:	00008067          	ret

00000494 <neorv32_dma_enable>:
/**********************************************************************//**
 * Enable DMA.
 **************************************************************************/
void neorv32_dma_enable(void) {

  NEORV32_DMA->CTRL |= (uint32_t)(1 << DMA_CTRL_EN);
     494:	fffff737          	lui	a4,0xfffff
     498:	d0072783          	lw	a5,-768(a4) # ffffed00 <__crt0_stack_begin+0x7fffcd04>
     49c:	0017e793          	ori	a5,a5,1
     4a0:	d0f72023          	sw	a5,-768(a4)
}
     4a4:	00008067          	ret

000004a8 <neorv32_dma_transfer>:
 * @param[in] num Number of elements to transfer (24-bit).
 * @param[in] config Transfer type configuration/commands.
 **************************************************************************/
void neorv32_dma_transfer(uint32_t base_src, uint32_t base_dst, uint32_t num, uint32_t config) {

  NEORV32_DMA->CTRL &= ~((uint32_t)(1 << DMA_CTRL_AUTO)); // manual transfer trigger
     4a8:	fffff737          	lui	a4,0xfffff
     4ac:	d0072803          	lw	a6,-768(a4) # ffffed00 <__crt0_stack_begin+0x7fffcd04>
     4b0:	d0070793          	addi	a5,a4,-768
  NEORV32_DMA->SRC_BASE = base_src;
  NEORV32_DMA->DST_BASE = base_dst;
  NEORV32_DMA->TTYPE    = (num & 0x00ffffffUL) | (config & 0xff000000UL); // trigger transfer
     4b4:	00861613          	slli	a2,a2,0x8
  NEORV32_DMA->CTRL &= ~((uint32_t)(1 << DMA_CTRL_AUTO)); // manual transfer trigger
     4b8:	ffd87813          	andi	a6,a6,-3
     4bc:	d1072023          	sw	a6,-768(a4)
  NEORV32_DMA->SRC_BASE = base_src;
     4c0:	d0a72223          	sw	a0,-764(a4)
  NEORV32_DMA->DST_BASE = base_dst;
     4c4:	d0b72423          	sw	a1,-760(a4)
  NEORV32_DMA->TTYPE    = (num & 0x00ffffffUL) | (config & 0xff000000UL); // trigger transfer
     4c8:	ff000737          	lui	a4,0xff000
     4cc:	00865613          	srli	a2,a2,0x8
     4d0:	00e6f6b3          	and	a3,a3,a4
     4d4:	00d66633          	or	a2,a2,a3
     4d8:	00c7a623          	sw	a2,12(a5) # 400000c <__neorv32_ram_size+0x3ffe00c>
}
     4dc:	00008067          	ret

000004e0 <neorv32_dma_status>:
 *
 * @return Current DMA status (#NEORV32_DMA_STATUS_enum)
 **************************************************************************/
int neorv32_dma_status(void) {

  uint32_t tmp = NEORV32_DMA->CTRL;
     4e0:	fffff7b7          	lui	a5,0xfffff
     4e4:	d007a783          	lw	a5,-768(a5) # ffffed00 <__crt0_stack_begin+0x7fffcd04>

  if (tmp & (1 << DMA_CTRL_ERROR_WR)) {
    return DMA_STATUS_ERR_WR; // error during write access
     4e8:	ffe00513          	li	a0,-2
  if (tmp & (1 << DMA_CTRL_ERROR_WR)) {
     4ec:	2007f713          	andi	a4,a5,512
     4f0:	00071c63          	bnez	a4,508 <neorv32_dma_status+0x28>
  }
  else if (tmp & (1 << DMA_CTRL_ERROR_RD)) {
     4f4:	1007f713          	andi	a4,a5,256
    return DMA_STATUS_ERR_RD; // error during read access
     4f8:	fff00513          	li	a0,-1
  else if (tmp & (1 << DMA_CTRL_ERROR_RD)) {
     4fc:	00071663          	bnez	a4,508 <neorv32_dma_status+0x28>
  }
  else if (tmp & (1 << DMA_CTRL_BUSY)) {
     500:	00a7d793          	srli	a5,a5,0xa
     504:	0017f513          	andi	a0,a5,1
    return DMA_STATUS_BUSY; // transfer in progress
  }
  else {
    return DMA_STATUS_IDLE; // idle
  }
}
     508:	00008067          	ret

0000050c <__neorv32_rte_core>:
/**********************************************************************//**
 * This is the [private!] core of the NEORV32 RTE.
 *
 * @warning When using the RTE this function is the ONLY function that uses the 'interrupt' attribute!
 **************************************************************************/
static void __attribute__((__interrupt__)) __attribute__((aligned(4))) __neorv32_rte_core(void) {
     50c:	fb010113          	addi	sp,sp,-80
     510:	04112623          	sw	ra,76(sp)
     514:	04512423          	sw	t0,72(sp)
     518:	04612223          	sw	t1,68(sp)
     51c:	04712023          	sw	t2,64(sp)
     520:	02812e23          	sw	s0,60(sp)
     524:	02a12c23          	sw	a0,56(sp)
     528:	02b12a23          	sw	a1,52(sp)
     52c:	02c12823          	sw	a2,48(sp)
     530:	02d12623          	sw	a3,44(sp)
     534:	02e12423          	sw	a4,40(sp)
     538:	02f12223          	sw	a5,36(sp)
     53c:	03012023          	sw	a6,32(sp)
     540:	01112e23          	sw	a7,28(sp)
     544:	01c12c23          	sw	t3,24(sp)
     548:	01d12a23          	sw	t4,20(sp)
     54c:	01e12823          	sw	t5,16(sp)
     550:	01f12623          	sw	t6,12(sp)
 **************************************************************************/
inline uint32_t __attribute__ ((always_inline)) neorv32_cpu_csr_read(const int csr_id) {

  uint32_t csr_data;

  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     554:	34202473          	csrr	s0,mcause

  uint32_t rte_mcause = neorv32_cpu_csr_read(CSR_MCAUSE);

  // find according trap handler
  uint32_t rte_handler;
  switch (rte_mcause) {
     558:	00b00793          	li	a5,11
     55c:	0287ea63          	bltu	a5,s0,590 <__neorv32_rte_core+0x84>
     560:	00001737          	lui	a4,0x1
     564:	00241793          	slli	a5,s0,0x2
     568:	24470713          	addi	a4,a4,580 # 1244 <__etext+0x230>
     56c:	00e787b3          	add	a5,a5,a4
     570:	0007a783          	lw	a5,0(a5)
     574:	00078067          	jr	a5
     578:	00001737          	lui	a4,0x1
     57c:	00279793          	slli	a5,a5,0x2
     580:	27470713          	addi	a4,a4,628 # 1274 <__etext+0x260>
     584:	00e787b3          	add	a5,a5,a4
     588:	0007a783          	lw	a5,0(a5)
     58c:	00078067          	jr	a5
     590:	800007b7          	lui	a5,0x80000
     594:	ffd7c793          	xori	a5,a5,-3
     598:	00f407b3          	add	a5,s0,a5
     59c:	01c00713          	li	a4,28
     5a0:	fcf77ce3          	bgeu	a4,a5,578 <__neorv32_rte_core+0x6c>
  }

  // execute handler
  void (*handler_pnt)(void);
  handler_pnt = (void*)rte_handler;
  (*handler_pnt)();
     5a4:	234000ef          	jal	ra,7d8 <__neorv32_rte_debug_handler>

  // compute return address
  if ((((int32_t)rte_mcause) >= 0) && // modify pc only if not interrupt (MSB cleared)
     5a8:	00045a63          	bgez	s0,5bc <__neorv32_rte_core+0xb0>
     5ac:	0500006f          	j	5fc <__neorv32_rte_core+0xf0>
  (*handler_pnt)();
     5b0:	800007b7          	lui	a5,0x80000
     5b4:	0207a783          	lw	a5,32(a5) # 80000020 <__crt0_stack_begin+0xffffe024>
     5b8:	000780e7          	jalr	a5
     5bc:	34102773          	csrr	a4,mepc
  asm volatile ("lbu %[da], 0(%[ad])" : [da] "=r" (reg_data) : [ad] "r" (reg_addr));
     5c0:	00074783          	lbu	a5,0(a4)
     5c4:	0ff7f793          	zext.b	a5,a5
    uint32_t rte_mepc = neorv32_cpu_csr_read(CSR_MEPC);

    // get opcode of faulting instruction
    uint32_t rte_trap_inst = (uint32_t)neorv32_cpu_load_unsigned_byte(rte_mepc);

    rte_mepc += 4; // default: faulting instruction is uncompressed
     5c8:	00470613          	addi	a2,a4,4
  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     5cc:	301026f3          	csrr	a3,misa
    if (neorv32_cpu_csr_read(CSR_MISA) & (1 << CSR_MISA_C)) { // C extension implemented?
     5d0:	0046f693          	andi	a3,a3,4
     5d4:	00068a63          	beqz	a3,5e8 <__neorv32_rte_core+0xdc>
      if ((rte_trap_inst & 3) != 3) { // faulting instruction is compressed instruction
     5d8:	0037f793          	andi	a5,a5,3
     5dc:	00300693          	li	a3,3
     5e0:	00d78463          	beq	a5,a3,5e8 <__neorv32_rte_core+0xdc>
        rte_mepc -= 2;
     5e4:	00270613          	addi	a2,a4,2
 **************************************************************************/
inline void __attribute__ ((always_inline)) neorv32_cpu_csr_write(const int csr_id, uint32_t data) {

  uint32_t csr_data = data;

  asm volatile ("csrw %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     5e8:	34161073          	csrw	mepc,a2
    }

    // store new return address
    neorv32_cpu_csr_write(CSR_MEPC, rte_mepc);
  }
}
     5ec:	0100006f          	j	5fc <__neorv32_rte_core+0xf0>
    case TRAP_CODE_I_ACCESS:     rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_I_ACCESS]; break;
     5f0:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     5f4:	0247a783          	lw	a5,36(a5) # 80000024 <__crt0_stack_begin+0xffffe028>
     5f8:	000780e7          	jalr	a5
}
     5fc:	03c12403          	lw	s0,60(sp)
     600:	04c12083          	lw	ra,76(sp)
     604:	04812283          	lw	t0,72(sp)
     608:	04412303          	lw	t1,68(sp)
     60c:	04012383          	lw	t2,64(sp)
     610:	03812503          	lw	a0,56(sp)
     614:	03412583          	lw	a1,52(sp)
     618:	03012603          	lw	a2,48(sp)
     61c:	02c12683          	lw	a3,44(sp)
     620:	02812703          	lw	a4,40(sp)
     624:	02412783          	lw	a5,36(sp)
     628:	02012803          	lw	a6,32(sp)
     62c:	01c12883          	lw	a7,28(sp)
     630:	01812e03          	lw	t3,24(sp)
     634:	01412e83          	lw	t4,20(sp)
     638:	01012f03          	lw	t5,16(sp)
     63c:	00c12f83          	lw	t6,12(sp)
     640:	05010113          	addi	sp,sp,80
     644:	30200073          	mret
    case TRAP_CODE_I_ILLEGAL:    rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_I_ILLEGAL]; break;
     648:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     64c:	0287a783          	lw	a5,40(a5) # 80000028 <__crt0_stack_begin+0xffffe02c>
     650:	f69ff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_BREAKPOINT:   rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_BREAKPOINT]; break;
     654:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     658:	02c7a783          	lw	a5,44(a5) # 8000002c <__crt0_stack_begin+0xffffe030>
     65c:	f5dff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_L_MISALIGNED: rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_L_MISALIGNED]; break;
     660:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     664:	0307a783          	lw	a5,48(a5) # 80000030 <__crt0_stack_begin+0xffffe034>
     668:	f51ff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_L_ACCESS:     rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_L_ACCESS]; break;
     66c:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     670:	0347a783          	lw	a5,52(a5) # 80000034 <__crt0_stack_begin+0xffffe038>
     674:	f45ff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_S_MISALIGNED: rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_S_MISALIGNED]; break;
     678:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     67c:	0387a783          	lw	a5,56(a5) # 80000038 <__crt0_stack_begin+0xffffe03c>
     680:	f39ff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_S_ACCESS:     rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_S_ACCESS]; break;
     684:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     688:	03c7a783          	lw	a5,60(a5) # 8000003c <__crt0_stack_begin+0xffffe040>
     68c:	f2dff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_UENV_CALL:    rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_UENV_CALL]; break;
     690:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     694:	0407a783          	lw	a5,64(a5) # 80000040 <__crt0_stack_begin+0xffffe044>
     698:	f21ff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_MENV_CALL:    rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_MENV_CALL]; break;
     69c:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     6a0:	0447a783          	lw	a5,68(a5) # 80000044 <__crt0_stack_begin+0xffffe048>
     6a4:	f15ff06f          	j	5b8 <__neorv32_rte_core+0xac>
    case TRAP_CODE_MSI:          rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_MSI]; break;
     6a8:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     6ac:	0487a783          	lw	a5,72(a5) # 80000048 <__crt0_stack_begin+0xffffe04c>
     6b0:	f49ff06f          	j	5f8 <__neorv32_rte_core+0xec>
    case TRAP_CODE_MTI:          rte_handler = __neorv32_rte_vector_lut[RTE_TRAP_MTI]; break;
     6b4:	800007b7          	lui	a5,0x80000
  (*handler_pnt)();
     6b8:	04c7a783          	lw	a5,76(a5) # 8000004c <__crt0_stack_begin+0xffffe050>
     6bc:	f3dff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6c0:	8501a783          	lw	a5,-1968(gp) # 80000050 <__neorv32_rte_vector_lut+0x30>
     6c4:	f35ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6c8:	8541a783          	lw	a5,-1964(gp) # 80000054 <__neorv32_rte_vector_lut+0x34>
     6cc:	f2dff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6d0:	8581a783          	lw	a5,-1960(gp) # 80000058 <__neorv32_rte_vector_lut+0x38>
     6d4:	f25ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6d8:	85c1a783          	lw	a5,-1956(gp) # 8000005c <__neorv32_rte_vector_lut+0x3c>
     6dc:	f1dff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6e0:	8601a783          	lw	a5,-1952(gp) # 80000060 <__neorv32_rte_vector_lut+0x40>
     6e4:	f15ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6e8:	8641a783          	lw	a5,-1948(gp) # 80000064 <__neorv32_rte_vector_lut+0x44>
     6ec:	f0dff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6f0:	8681a783          	lw	a5,-1944(gp) # 80000068 <__neorv32_rte_vector_lut+0x48>
     6f4:	f05ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     6f8:	86c1a783          	lw	a5,-1940(gp) # 8000006c <__neorv32_rte_vector_lut+0x4c>
     6fc:	efdff06f          	j	5f8 <__neorv32_rte_core+0xec>
     700:	8701a783          	lw	a5,-1936(gp) # 80000070 <__neorv32_rte_vector_lut+0x50>
     704:	ef5ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     708:	8741a783          	lw	a5,-1932(gp) # 80000074 <__neorv32_rte_vector_lut+0x54>
     70c:	eedff06f          	j	5f8 <__neorv32_rte_core+0xec>
     710:	8781a783          	lw	a5,-1928(gp) # 80000078 <__neorv32_rte_vector_lut+0x58>
     714:	ee5ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     718:	87c1a783          	lw	a5,-1924(gp) # 8000007c <__neorv32_rte_vector_lut+0x5c>
     71c:	eddff06f          	j	5f8 <__neorv32_rte_core+0xec>
     720:	8801a783          	lw	a5,-1920(gp) # 80000080 <__neorv32_rte_vector_lut+0x60>
     724:	ed5ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     728:	8841a783          	lw	a5,-1916(gp) # 80000084 <__neorv32_rte_vector_lut+0x64>
     72c:	ecdff06f          	j	5f8 <__neorv32_rte_core+0xec>
     730:	8881a783          	lw	a5,-1912(gp) # 80000088 <__neorv32_rte_vector_lut+0x68>
     734:	ec5ff06f          	j	5f8 <__neorv32_rte_core+0xec>
     738:	88c1a783          	lw	a5,-1908(gp) # 8000008c <__neorv32_rte_vector_lut+0x6c>
     73c:	ebdff06f          	j	5f8 <__neorv32_rte_core+0xec>
     740:	8901a783          	lw	a5,-1904(gp) # 80000090 <__neorv32_rte_vector_lut+0x70>
     744:	eb5ff06f          	j	5f8 <__neorv32_rte_core+0xec>

00000748 <__neorv32_rte_print_hex_word>:
 * NEORV32 runtime environment: Private function to print 32-bit number
 * as 8-digit hexadecimal value (with "0x" suffix).
 *
 * @param[in] num Number to print as hexadecimal.
 **************************************************************************/
void __neorv32_rte_print_hex_word(uint32_t num) {
     748:	fe010113          	addi	sp,sp,-32
     74c:	00812c23          	sw	s0,24(sp)

  static const char hex_symbols[16] = "0123456789ABCDEF";

  neorv32_uart0_putc('0');
     750:	fffff437          	lui	s0,0xfffff
void __neorv32_rte_print_hex_word(uint32_t num) {
     754:	01312623          	sw	s3,12(sp)
  neorv32_uart0_putc('0');
     758:	03000593          	li	a1,48
void __neorv32_rte_print_hex_word(uint32_t num) {
     75c:	00050993          	mv	s3,a0
  neorv32_uart0_putc('0');
     760:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
void __neorv32_rte_print_hex_word(uint32_t num) {
     764:	00112e23          	sw	ra,28(sp)
     768:	00912a23          	sw	s1,20(sp)
     76c:	01212823          	sw	s2,16(sp)
     770:	01412423          	sw	s4,8(sp)
  neorv32_uart0_putc('0');
     774:	520000ef          	jal	ra,c94 <neorv32_uart_putc>
  neorv32_uart0_putc('x');
     778:	50040513          	addi	a0,s0,1280
     77c:	07800593          	li	a1,120

  int i;
  for (i=0; i<8; i++) {
    uint32_t index = (num >> (28 - 4*i)) & 0xF;
    neorv32_uart0_putc(hex_symbols[index]);
     780:	00001937          	lui	s2,0x1
  neorv32_uart0_putc('x');
     784:	510000ef          	jal	ra,c94 <neorv32_uart_putc>
     788:	01c00493          	li	s1,28
    neorv32_uart0_putc(hex_symbols[index]);
     78c:	4d490913          	addi	s2,s2,1236 # 14d4 <hex_symbols.0>
     790:	50040413          	addi	s0,s0,1280
  for (i=0; i<8; i++) {
     794:	ffc00a13          	li	s4,-4
    uint32_t index = (num >> (28 - 4*i)) & 0xF;
     798:	0099d7b3          	srl	a5,s3,s1
     79c:	00f7f793          	andi	a5,a5,15
    neorv32_uart0_putc(hex_symbols[index]);
     7a0:	00f907b3          	add	a5,s2,a5
     7a4:	0007c583          	lbu	a1,0(a5)
     7a8:	00040513          	mv	a0,s0
  for (i=0; i<8; i++) {
     7ac:	ffc48493          	addi	s1,s1,-4
    neorv32_uart0_putc(hex_symbols[index]);
     7b0:	4e4000ef          	jal	ra,c94 <neorv32_uart_putc>
  for (i=0; i<8; i++) {
     7b4:	ff4492e3          	bne	s1,s4,798 <__neorv32_rte_print_hex_word+0x50>
  }
}
     7b8:	01c12083          	lw	ra,28(sp)
     7bc:	01812403          	lw	s0,24(sp)
     7c0:	01412483          	lw	s1,20(sp)
     7c4:	01012903          	lw	s2,16(sp)
     7c8:	00c12983          	lw	s3,12(sp)
     7cc:	00812a03          	lw	s4,8(sp)
     7d0:	02010113          	addi	sp,sp,32
     7d4:	00008067          	ret

000007d8 <__neorv32_rte_debug_handler>:
static void __neorv32_rte_debug_handler(void) {
     7d8:	ff010113          	addi	sp,sp,-16
     7dc:	00812423          	sw	s0,8(sp)
  if (neorv32_uart0_available() == 0) {
     7e0:	fffff437          	lui	s0,0xfffff
     7e4:	50040513          	addi	a0,s0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
static void __neorv32_rte_debug_handler(void) {
     7e8:	00112623          	sw	ra,12(sp)
     7ec:	00912223          	sw	s1,4(sp)
  if (neorv32_uart0_available() == 0) {
     7f0:	3d0000ef          	jal	ra,bc0 <neorv32_uart_available>
     7f4:	20050263          	beqz	a0,9f8 <__neorv32_rte_debug_handler+0x220>
  neorv32_uart0_puts("<RTE> ");
     7f8:	000015b7          	lui	a1,0x1
     7fc:	2e858593          	addi	a1,a1,744 # 12e8 <__etext+0x2d4>
     800:	50040513          	addi	a0,s0,1280
     804:	4a8000ef          	jal	ra,cac <neorv32_uart_puts>
  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     808:	300027f3          	csrr	a5,mstatus
  if (neorv32_cpu_csr_read(CSR_MSTATUS) & (3 << CSR_MSTATUS_MPP_L)) {
     80c:	00002737          	lui	a4,0x2
     810:	80070713          	addi	a4,a4,-2048 # 1800 <__RODATA_END__+0x2fc>
     814:	00e7f7b3          	and	a5,a5,a4
     818:	02078c63          	beqz	a5,850 <__neorv32_rte_debug_handler+0x78>
    neorv32_uart0_puts("[M] "); // machine-mode
     81c:	000015b7          	lui	a1,0x1
     820:	2f058593          	addi	a1,a1,752 # 12f0 <__etext+0x2dc>
    neorv32_uart0_puts("[U] "); // user-mode
     824:	50040513          	addi	a0,s0,1280
     828:	484000ef          	jal	ra,cac <neorv32_uart_puts>
     82c:	34202473          	csrr	s0,mcause
  switch (trap_cause) {
     830:	00b00793          	li	a5,11
     834:	0287e463          	bltu	a5,s0,85c <__neorv32_rte_debug_handler+0x84>
     838:	00001737          	lui	a4,0x1
     83c:	00241793          	slli	a5,s0,0x2
     840:	4a470713          	addi	a4,a4,1188 # 14a4 <__etext+0x490>
     844:	00e787b3          	add	a5,a5,a4
     848:	0007a783          	lw	a5,0(a5)
     84c:	00078067          	jr	a5
    neorv32_uart0_puts("[U] "); // user-mode
     850:	000015b7          	lui	a1,0x1
     854:	2f858593          	addi	a1,a1,760 # 12f8 <__etext+0x2e4>
     858:	fcdff06f          	j	824 <__neorv32_rte_debug_handler+0x4c>
  switch (trap_cause) {
     85c:	800007b7          	lui	a5,0x80000
     860:	00b78713          	addi	a4,a5,11 # 8000000b <__crt0_stack_begin+0xffffe00f>
     864:	16e40463          	beq	s0,a4,9cc <__neorv32_rte_debug_handler+0x1f4>
     868:	02876a63          	bltu	a4,s0,89c <__neorv32_rte_debug_handler+0xc4>
     86c:	00378713          	addi	a4,a5,3
     870:	14e40263          	beq	s0,a4,9b4 <__neorv32_rte_debug_handler+0x1dc>
     874:	00778793          	addi	a5,a5,7
     878:	14f40463          	beq	s0,a5,9c0 <__neorv32_rte_debug_handler+0x1e8>
    default:                     neorv32_uart0_puts("UNKNOWN trap cause "); __neorv32_rte_print_hex_word(trap_cause); break;
     87c:	000015b7          	lui	a1,0x1
     880:	fffff537          	lui	a0,0xfffff
     884:	44858593          	addi	a1,a1,1096 # 1448 <__etext+0x434>
     888:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     88c:	420000ef          	jal	ra,cac <neorv32_uart_puts>
     890:	00040513          	mv	a0,s0
     894:	eb5ff0ef          	jal	ra,748 <__neorv32_rte_print_hex_word>
  if ((trap_cause >= TRAP_CODE_FIRQ_0) && (trap_cause <= TRAP_CODE_FIRQ_15)) {
     898:	05c0006f          	j	8f4 <__neorv32_rte_debug_handler+0x11c>
  switch (trap_cause) {
     89c:	ff07c793          	xori	a5,a5,-16
     8a0:	00f407b3          	add	a5,s0,a5
     8a4:	00f00713          	li	a4,15
     8a8:	fcf76ae3          	bltu	a4,a5,87c <__neorv32_rte_debug_handler+0xa4>
    case TRAP_CODE_FIRQ_15:      neorv32_uart0_puts("Fast IRQ "); __neorv32_rte_print_hex_word(trap_cause & 0xf); break;
     8ac:	000015b7          	lui	a1,0x1
     8b0:	fffff537          	lui	a0,0xfffff
     8b4:	43c58593          	addi	a1,a1,1084 # 143c <__etext+0x428>
     8b8:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     8bc:	3f0000ef          	jal	ra,cac <neorv32_uart_puts>
     8c0:	00f47493          	andi	s1,s0,15
     8c4:	00048513          	mv	a0,s1
     8c8:	e81ff0ef          	jal	ra,748 <__neorv32_rte_print_hex_word>
    neorv32_cpu_csr_clr(CSR_MIP, 1 << (CSR_MIP_FIRQ0P + (trap_cause & 0xf))); // clear pending FIRQ
     8cc:	01048493          	addi	s1,s1,16
     8d0:	00100793          	li	a5,1
     8d4:	009797b3          	sll	a5,a5,s1
 **************************************************************************/
inline void __attribute__ ((always_inline)) neorv32_cpu_csr_clr(const int csr_id, uint32_t mask) {

  uint32_t csr_data = mask;

  asm volatile ("csrc %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     8d8:	3447b073          	csrc	mip,a5
}
     8dc:	0180006f          	j	8f4 <__neorv32_rte_debug_handler+0x11c>
    case TRAP_CODE_I_MISALIGNED: neorv32_uart0_puts("Instruction address misaligned"); break;
     8e0:	000015b7          	lui	a1,0x1
     8e4:	30058593          	addi	a1,a1,768 # 1300 <__etext+0x2ec>
    case TRAP_CODE_MEI:          neorv32_uart0_puts("Machine external IRQ"); break;
     8e8:	fffff537          	lui	a0,0xfffff
     8ec:	50050513          	addi	a0,a0,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     8f0:	3bc000ef          	jal	ra,cac <neorv32_uart_puts>
  neorv32_uart0_puts(" @ PC=");
     8f4:	fffff4b7          	lui	s1,0xfffff
     8f8:	000015b7          	lui	a1,0x1
     8fc:	45c58593          	addi	a1,a1,1116 # 145c <__etext+0x448>
     900:	50048513          	addi	a0,s1,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
     904:	3a8000ef          	jal	ra,cac <neorv32_uart_puts>
  asm volatile ("csrr %[result], %[input_i]" : [result] "=r" (csr_data) : [input_i] "i" (csr_id));
     908:	34102573          	csrr	a0,mepc
  __neorv32_rte_print_hex_word(mepc);
     90c:	e3dff0ef          	jal	ra,748 <__neorv32_rte_print_hex_word>
  neorv32_uart0_puts(", MTVAL=");
     910:	000015b7          	lui	a1,0x1
     914:	46458593          	addi	a1,a1,1124 # 1464 <__etext+0x450>
     918:	50048513          	addi	a0,s1,1280
     91c:	390000ef          	jal	ra,cac <neorv32_uart_puts>
     920:	34302573          	csrr	a0,mtval
  __neorv32_rte_print_hex_word(neorv32_cpu_csr_read(CSR_MTVAL));
     924:	e25ff0ef          	jal	ra,748 <__neorv32_rte_print_hex_word>
  if ((trap_cause == TRAP_CODE_I_ACCESS) || (trap_cause == TRAP_CODE_I_MISALIGNED)) {
     928:	00100793          	li	a5,1
     92c:	0a87e663          	bltu	a5,s0,9d8 <__neorv32_rte_debug_handler+0x200>
    neorv32_uart0_puts(" [FATAL EXCEPTION] Halting CPU. </RTE>\n");
     930:	000015b7          	lui	a1,0x1
     934:	47058593          	addi	a1,a1,1136 # 1470 <__etext+0x45c>
     938:	50048513          	addi	a0,s1,1280
     93c:	370000ef          	jal	ra,cac <neorv32_uart_puts>
      asm volatile ("wfi");
     940:	10500073          	wfi
    while(1) {
     944:	ffdff06f          	j	940 <__neorv32_rte_debug_handler+0x168>
    case TRAP_CODE_I_ACCESS:     neorv32_uart0_puts("Instruction access fault"); break;
     948:	000015b7          	lui	a1,0x1
     94c:	32058593          	addi	a1,a1,800 # 1320 <__etext+0x30c>
     950:	f99ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_I_ILLEGAL:    neorv32_uart0_puts("Illegal instruction"); break;
     954:	000015b7          	lui	a1,0x1
     958:	33c58593          	addi	a1,a1,828 # 133c <__etext+0x328>
     95c:	f8dff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_BREAKPOINT:   neorv32_uart0_puts("Breakpoint"); break;
     960:	000015b7          	lui	a1,0x1
     964:	35058593          	addi	a1,a1,848 # 1350 <__etext+0x33c>
     968:	f81ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_L_MISALIGNED: neorv32_uart0_puts("Load address misaligned"); break;
     96c:	000015b7          	lui	a1,0x1
     970:	35c58593          	addi	a1,a1,860 # 135c <__etext+0x348>
     974:	f75ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_L_ACCESS:     neorv32_uart0_puts("Load access fault"); break;
     978:	000015b7          	lui	a1,0x1
     97c:	37458593          	addi	a1,a1,884 # 1374 <__etext+0x360>
     980:	f69ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_S_MISALIGNED: neorv32_uart0_puts("Store address misaligned"); break;
     984:	000015b7          	lui	a1,0x1
     988:	38858593          	addi	a1,a1,904 # 1388 <__etext+0x374>
     98c:	f5dff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_S_ACCESS:     neorv32_uart0_puts("Store access fault"); break;
     990:	000015b7          	lui	a1,0x1
     994:	3a458593          	addi	a1,a1,932 # 13a4 <__etext+0x390>
     998:	f51ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_UENV_CALL:    neorv32_uart0_puts("Environment call from U-mode"); break;
     99c:	000015b7          	lui	a1,0x1
     9a0:	3b858593          	addi	a1,a1,952 # 13b8 <__etext+0x3a4>
     9a4:	f45ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MENV_CALL:    neorv32_uart0_puts("Environment call from M-mode"); break;
     9a8:	000015b7          	lui	a1,0x1
     9ac:	3d858593          	addi	a1,a1,984 # 13d8 <__etext+0x3c4>
     9b0:	f39ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MSI:          neorv32_uart0_puts("Machine software IRQ"); break;
     9b4:	000015b7          	lui	a1,0x1
     9b8:	3f858593          	addi	a1,a1,1016 # 13f8 <__etext+0x3e4>
     9bc:	f2dff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MTI:          neorv32_uart0_puts("Machine timer IRQ"); break;
     9c0:	000015b7          	lui	a1,0x1
     9c4:	41058593          	addi	a1,a1,1040 # 1410 <__etext+0x3fc>
     9c8:	f21ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
    case TRAP_CODE_MEI:          neorv32_uart0_puts("Machine external IRQ"); break;
     9cc:	000015b7          	lui	a1,0x1
     9d0:	42458593          	addi	a1,a1,1060 # 1424 <__etext+0x410>
     9d4:	f15ff06f          	j	8e8 <__neorv32_rte_debug_handler+0x110>
}
     9d8:	00812403          	lw	s0,8(sp)
     9dc:	00c12083          	lw	ra,12(sp)
  neorv32_uart0_puts(" </RTE>\n");
     9e0:	50048513          	addi	a0,s1,1280
}
     9e4:	00412483          	lw	s1,4(sp)
  neorv32_uart0_puts(" </RTE>\n");
     9e8:	000015b7          	lui	a1,0x1
     9ec:	49858593          	addi	a1,a1,1176 # 1498 <__etext+0x484>
}
     9f0:	01010113          	addi	sp,sp,16
  neorv32_uart0_puts(" </RTE>\n");
     9f4:	2b80006f          	j	cac <neorv32_uart_puts>
}
     9f8:	00c12083          	lw	ra,12(sp)
     9fc:	00812403          	lw	s0,8(sp)
     a00:	00412483          	lw	s1,4(sp)
     a04:	01010113          	addi	sp,sp,16
     a08:	00008067          	ret

00000a0c <neorv32_rte_handler_install>:
  if ((id >= (int)RTE_TRAP_I_MISALIGNED) && (id <= (int)RTE_TRAP_FIRQ_15)) {
     a0c:	01c00793          	li	a5,28
     a10:	02a7e063          	bltu	a5,a0,a30 <neorv32_rte_handler_install+0x24>
    __neorv32_rte_vector_lut[id] = (uint32_t)handler; // install handler
     a14:	800007b7          	lui	a5,0x80000
     a18:	00251513          	slli	a0,a0,0x2
     a1c:	02078793          	addi	a5,a5,32 # 80000020 <__crt0_stack_begin+0xffffe024>
     a20:	00a787b3          	add	a5,a5,a0
     a24:	00b7a023          	sw	a1,0(a5)
    return 0;
     a28:	00000513          	li	a0,0
     a2c:	00008067          	ret
  return 1;
     a30:	00100513          	li	a0,1
}
     a34:	00008067          	ret

00000a38 <neorv32_rte_handler_uninstall>:
  if ((id >= (int)RTE_TRAP_I_MISALIGNED) && (id <= (int)RTE_TRAP_FIRQ_15)) {
     a38:	01c00793          	li	a5,28
     a3c:	02a7e263          	bltu	a5,a0,a60 <neorv32_rte_handler_uninstall+0x28>
    __neorv32_rte_vector_lut[id] = (uint32_t)(&__neorv32_rte_debug_handler); // use dummy handler in case the trap is accidentally triggered
     a40:	800007b7          	lui	a5,0x80000
     a44:	00251513          	slli	a0,a0,0x2
     a48:	02078793          	addi	a5,a5,32 # 80000020 <__crt0_stack_begin+0xffffe024>
     a4c:	00a787b3          	add	a5,a5,a0
     a50:	7d800713          	li	a4,2008
     a54:	00e7a023          	sw	a4,0(a5)
    return 0;
     a58:	00000513          	li	a0,0
     a5c:	00008067          	ret
  return 1;
     a60:	00100513          	li	a0,1
}
     a64:	00008067          	ret

00000a68 <neorv32_rte_setup>:
void neorv32_rte_setup(void) {
     a68:	ff010113          	addi	sp,sp,-16
     a6c:	00112623          	sw	ra,12(sp)
     a70:	00812423          	sw	s0,8(sp)
     a74:	00912223          	sw	s1,4(sp)
  asm volatile ("csrw %[input_i], %[input_j]" :  : [input_i] "i" (csr_id), [input_j] "r" (csr_data));
     a78:	50c00793          	li	a5,1292
     a7c:	30579073          	csrw	mtvec,a5
     a80:	00000793          	li	a5,0
     a84:	30479073          	csrw	mie,a5
     a88:	34479073          	csrw	mip,a5
     a8c:	00000413          	li	s0,0
  for (id = 0; id < (sizeof(__neorv32_rte_vector_lut)/sizeof(__neorv32_rte_vector_lut[0])); id++) {
     a90:	01d00493          	li	s1,29
    neorv32_rte_handler_uninstall(id); // this will configure the debug handler
     a94:	00040513          	mv	a0,s0
  for (id = 0; id < (sizeof(__neorv32_rte_vector_lut)/sizeof(__neorv32_rte_vector_lut[0])); id++) {
     a98:	00140413          	addi	s0,s0,1
    neorv32_rte_handler_uninstall(id); // this will configure the debug handler
     a9c:	f9dff0ef          	jal	ra,a38 <neorv32_rte_handler_uninstall>
  for (id = 0; id < (sizeof(__neorv32_rte_vector_lut)/sizeof(__neorv32_rte_vector_lut[0])); id++) {
     aa0:	fe941ae3          	bne	s0,s1,a94 <neorv32_rte_setup+0x2c>
}
     aa4:	00c12083          	lw	ra,12(sp)
     aa8:	00812403          	lw	s0,8(sp)
     aac:	00412483          	lw	s1,4(sp)
     ab0:	01010113          	addi	sp,sp,16
     ab4:	00008067          	ret

00000ab8 <__neorv32_uart_itoa>:
 * Private function for 'neorv32_printf' to convert into decimal.
 *
 * @param[in] x Unsigned input number.
 * @param[in,out] res Pointer for storing the reuslting number string (11 chars).
 **************************************************************************/
static void __neorv32_uart_itoa(uint32_t x, char *res) {
     ab8:	fd010113          	addi	sp,sp,-48
     abc:	02812423          	sw	s0,40(sp)
     ac0:	02912223          	sw	s1,36(sp)
     ac4:	03212023          	sw	s2,32(sp)
     ac8:	01312e23          	sw	s3,28(sp)
     acc:	01412c23          	sw	s4,24(sp)
     ad0:	02112623          	sw	ra,44(sp)
     ad4:	01512a23          	sw	s5,20(sp)
  buffer1[10] = '\0';
  res[10] = '\0';

  // convert
  for (i=0; i<10; i++) {
    buffer1[i] = numbers[x%10];
     ad8:	00001a37          	lui	s4,0x1
static void __neorv32_uart_itoa(uint32_t x, char *res) {
     adc:	00050493          	mv	s1,a0
     ae0:	00058413          	mv	s0,a1
  res[10] = '\0';
     ae4:	00058523          	sb	zero,10(a1)
     ae8:	00000993          	li	s3,0
    buffer1[i] = numbers[x%10];
     aec:	00410913          	addi	s2,sp,4
     af0:	4f8a0a13          	addi	s4,s4,1272 # 14f8 <numbers.1>
     af4:	00a00593          	li	a1,10
     af8:	00048513          	mv	a0,s1
     afc:	4b4000ef          	jal	ra,fb0 <__umodsi3>
     b00:	00aa0533          	add	a0,s4,a0
     b04:	00054783          	lbu	a5,0(a0)
     b08:	01390ab3          	add	s5,s2,s3
    x /= 10;
     b0c:	00048513          	mv	a0,s1
    buffer1[i] = numbers[x%10];
     b10:	00fa8023          	sb	a5,0(s5)
    x /= 10;
     b14:	00a00593          	li	a1,10
     b18:	450000ef          	jal	ra,f68 <__hidden___udivsi3>
  for (i=0; i<10; i++) {
     b1c:	00198993          	addi	s3,s3,1
     b20:	00a00793          	li	a5,10
    x /= 10;
     b24:	00050493          	mv	s1,a0
  for (i=0; i<10; i++) {
     b28:	fcf996e3          	bne	s3,a5,af4 <__neorv32_uart_itoa+0x3c>
     b2c:	00090693          	mv	a3,s2
  }

  // delete 'leading' zeros
  for (i=9; i!=0; i--) {
     b30:	00900713          	li	a4,9
    if (buffer1[i] == '0')
     b34:	03000613          	li	a2,48
     b38:	0096c583          	lbu	a1,9(a3) # 58000009 <__neorv32_ram_size+0x57ffe009>
     b3c:	00070793          	mv	a5,a4
  for (i=9; i!=0; i--) {
     b40:	fff70713          	addi	a4,a4,-1
     b44:	01071713          	slli	a4,a4,0x10
     b48:	01075713          	srli	a4,a4,0x10
    if (buffer1[i] == '0')
     b4c:	00c59a63          	bne	a1,a2,b60 <__neorv32_uart_itoa+0xa8>
      buffer1[i] = '\0';
     b50:	000684a3          	sb	zero,9(a3)
  for (i=9; i!=0; i--) {
     b54:	fff68693          	addi	a3,a3,-1
     b58:	fe0710e3          	bnez	a4,b38 <__neorv32_uart_itoa+0x80>
     b5c:	00000793          	li	a5,0
     b60:	00f907b3          	add	a5,s2,a5
     b64:	00000713          	li	a4,0
  }

  // reverse
  j = 0;
  do {
    if (buffer1[i] != '\0')
     b68:	0007c683          	lbu	a3,0(a5)
     b6c:	00068c63          	beqz	a3,b84 <__neorv32_uart_itoa+0xcc>
      res[j++] = buffer1[i];
     b70:	00170613          	addi	a2,a4,1
     b74:	00e40733          	add	a4,s0,a4
     b78:	00d70023          	sb	a3,0(a4)
     b7c:	01061713          	slli	a4,a2,0x10
     b80:	01075713          	srli	a4,a4,0x10
  } while (i--);
     b84:	fff78693          	addi	a3,a5,-1
     b88:	02f91863          	bne	s2,a5,bb8 <__neorv32_uart_itoa+0x100>

  res[j] = '\0'; // terminate result string
     b8c:	00e40433          	add	s0,s0,a4
     b90:	00040023          	sb	zero,0(s0)
}
     b94:	02c12083          	lw	ra,44(sp)
     b98:	02812403          	lw	s0,40(sp)
     b9c:	02412483          	lw	s1,36(sp)
     ba0:	02012903          	lw	s2,32(sp)
     ba4:	01c12983          	lw	s3,28(sp)
     ba8:	01812a03          	lw	s4,24(sp)
     bac:	01412a83          	lw	s5,20(sp)
     bb0:	03010113          	addi	sp,sp,48
     bb4:	00008067          	ret
     bb8:	00068793          	mv	a5,a3
     bbc:	fadff06f          	j	b68 <__neorv32_uart_itoa+0xb0>

00000bc0 <neorv32_uart_available>:
  if ( ((uint32_t)UARTx == NEORV32_UART0_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART0)) ) {
     bc0:	fffff7b7          	lui	a5,0xfffff
     bc4:	50078693          	addi	a3,a5,1280 # fffff500 <__crt0_stack_begin+0x7fffd504>
int neorv32_uart_available (neorv32_uart_t *UARTx) {
     bc8:	00050713          	mv	a4,a0
  if ( ((uint32_t)UARTx == NEORV32_UART0_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART0)) ) {
     bcc:	00d51a63          	bne	a0,a3,be0 <neorv32_uart_available+0x20>
     bd0:	e0802503          	lw	a0,-504(zero) # fffffe08 <__crt0_stack_begin+0x7fffde0c>
     bd4:	01155513          	srli	a0,a0,0x11
  if ( ((uint32_t)UARTx == NEORV32_UART1_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART1)) ) {
     bd8:	00157513          	andi	a0,a0,1
}
     bdc:	00008067          	ret
  if ( ((uint32_t)UARTx == NEORV32_UART1_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART1)) ) {
     be0:	60078793          	addi	a5,a5,1536
  int available = 0;
     be4:	00000513          	li	a0,0
  if ( ((uint32_t)UARTx == NEORV32_UART1_BASE) && (NEORV32_SYSINFO->SOC & (1 << SYSINFO_SOC_IO_UART1)) ) {
     be8:	fef71ae3          	bne	a4,a5,bdc <neorv32_uart_available+0x1c>
     bec:	e0802503          	lw	a0,-504(zero) # fffffe08 <__crt0_stack_begin+0x7fffde0c>
     bf0:	01955513          	srli	a0,a0,0x19
     bf4:	fe5ff06f          	j	bd8 <neorv32_uart_available+0x18>

00000bf8 <neorv32_uart_setup>:
void neorv32_uart_setup(neorv32_uart_t *UARTx, uint32_t baudrate, uint32_t irq_mask) {
     bf8:	ff010113          	addi	sp,sp,-16
     bfc:	00812423          	sw	s0,8(sp)
     c00:	00912223          	sw	s1,4(sp)
     c04:	00112623          	sw	ra,12(sp)
  UARTx->CTRL = 0;
     c08:	00052023          	sw	zero,0(a0)
void neorv32_uart_setup(neorv32_uart_t *UARTx, uint32_t baudrate, uint32_t irq_mask) {
     c0c:	00050493          	mv	s1,a0
  uint32_t clock = NEORV32_SYSINFO->CLK; // system clock in Hz
     c10:	e0002503          	lw	a0,-512(zero) # fffffe00 <__crt0_stack_begin+0x7fffde04>
  baud_div = clock / (2*baudrate);
     c14:	00159593          	slli	a1,a1,0x1
void neorv32_uart_setup(neorv32_uart_t *UARTx, uint32_t baudrate, uint32_t irq_mask) {
     c18:	00060413          	mv	s0,a2
  baud_div = clock / (2*baudrate);
     c1c:	34c000ef          	jal	ra,f68 <__hidden___udivsi3>
  uint32_t prsc_sel = 0;
     c20:	00000713          	li	a4,0
  while (baud_div >= 0x3ffU) {
     c24:	3fe00693          	li	a3,1022
     c28:	04a6e663          	bltu	a3,a0,c74 <neorv32_uart_setup+0x7c>
  tmp |= (uint32_t)((baud_div - 1) & 0x3ffU) << UART_CTRL_BAUD0;
     c2c:	fff50793          	addi	a5,a0,-1
     c30:	000106b7          	lui	a3,0x10
     c34:	fff68693          	addi	a3,a3,-1 # ffff <__neorv32_ram_size+0xdfff>
     c38:	00679793          	slli	a5,a5,0x6
     c3c:	00d7f7b3          	and	a5,a5,a3
  tmp |= (uint32_t)(irq_mask & (0x1fU << UART_CTRL_IRQ_RX_NEMPTY));
     c40:	07c006b7          	lui	a3,0x7c00
     c44:	00d47433          	and	s0,s0,a3
  tmp |= (uint32_t)(prsc_sel       & 3U)     << UART_CTRL_PRSC0;
     c48:	00371713          	slli	a4,a4,0x3
  tmp |= (uint32_t)(irq_mask & (0x1fU << UART_CTRL_IRQ_RX_NEMPTY));
     c4c:	0087e7b3          	or	a5,a5,s0
  tmp |= (uint32_t)(prsc_sel       & 3U)     << UART_CTRL_PRSC0;
     c50:	01877713          	andi	a4,a4,24
}
     c54:	00c12083          	lw	ra,12(sp)
     c58:	00812403          	lw	s0,8(sp)
  tmp |= (uint32_t)(irq_mask & (0x1fU << UART_CTRL_IRQ_RX_NEMPTY));
     c5c:	00e7e7b3          	or	a5,a5,a4
     c60:	0017e793          	ori	a5,a5,1
  UARTx->CTRL = tmp;
     c64:	00f4a023          	sw	a5,0(s1)
}
     c68:	00412483          	lw	s1,4(sp)
     c6c:	01010113          	addi	sp,sp,16
     c70:	00008067          	ret
    if ((prsc_sel == 2) || (prsc_sel == 4))
     c74:	ffe70793          	addi	a5,a4,-2
     c78:	ffd7f793          	andi	a5,a5,-3
     c7c:	00079863          	bnez	a5,c8c <neorv32_uart_setup+0x94>
      baud_div >>= 3;
     c80:	00355513          	srli	a0,a0,0x3
    prsc_sel++;
     c84:	00170713          	addi	a4,a4,1
     c88:	fa1ff06f          	j	c28 <neorv32_uart_setup+0x30>
      baud_div >>= 1;
     c8c:	00155513          	srli	a0,a0,0x1
     c90:	ff5ff06f          	j	c84 <neorv32_uart_setup+0x8c>

00000c94 <neorv32_uart_putc>:
  while ((UARTx->CTRL & (1<<UART_CTRL_TX_FULL))); // wait for free space in TX FIFO
     c94:	00200737          	lui	a4,0x200
     c98:	00052783          	lw	a5,0(a0)
     c9c:	00e7f7b3          	and	a5,a5,a4
     ca0:	fe079ce3          	bnez	a5,c98 <neorv32_uart_putc+0x4>
  UARTx->DATA = (uint32_t)c << UART_DATA_RTX_LSB;
     ca4:	00b52223          	sw	a1,4(a0)
}
     ca8:	00008067          	ret

00000cac <neorv32_uart_puts>:
void neorv32_uart_puts(neorv32_uart_t *UARTx, const char *s) {
     cac:	fe010113          	addi	sp,sp,-32
     cb0:	00812c23          	sw	s0,24(sp)
     cb4:	00912a23          	sw	s1,20(sp)
     cb8:	01312623          	sw	s3,12(sp)
     cbc:	00112e23          	sw	ra,28(sp)
     cc0:	01212823          	sw	s2,16(sp)
     cc4:	00050493          	mv	s1,a0
     cc8:	00058413          	mv	s0,a1
    if (c == '\n') {
     ccc:	00a00993          	li	s3,10
  while ((c = *s++)) {
     cd0:	00044903          	lbu	s2,0(s0)
     cd4:	00140413          	addi	s0,s0,1
     cd8:	02091063          	bnez	s2,cf8 <neorv32_uart_puts+0x4c>
}
     cdc:	01c12083          	lw	ra,28(sp)
     ce0:	01812403          	lw	s0,24(sp)
     ce4:	01412483          	lw	s1,20(sp)
     ce8:	01012903          	lw	s2,16(sp)
     cec:	00c12983          	lw	s3,12(sp)
     cf0:	02010113          	addi	sp,sp,32
     cf4:	00008067          	ret
    if (c == '\n') {
     cf8:	01391863          	bne	s2,s3,d08 <neorv32_uart_puts+0x5c>
      neorv32_uart_putc(UARTx, '\r');
     cfc:	00d00593          	li	a1,13
     d00:	00048513          	mv	a0,s1
     d04:	f91ff0ef          	jal	ra,c94 <neorv32_uart_putc>
    neorv32_uart_putc(UARTx, c);
     d08:	00090593          	mv	a1,s2
     d0c:	00048513          	mv	a0,s1
     d10:	f85ff0ef          	jal	ra,c94 <neorv32_uart_putc>
     d14:	fbdff06f          	j	cd0 <neorv32_uart_puts+0x24>

00000d18 <neorv32_uart_printf>:
void neorv32_uart_printf(neorv32_uart_t *UARTx, const char *format, ...) {
     d18:	fa010113          	addi	sp,sp,-96
     d1c:	04f12a23          	sw	a5,84(sp)
  va_start(a, format);
     d20:	04810793          	addi	a5,sp,72
void neorv32_uart_printf(neorv32_uart_t *UARTx, const char *format, ...) {
     d24:	02912a23          	sw	s1,52(sp)
     d28:	03212823          	sw	s2,48(sp)
     d2c:	03312623          	sw	s3,44(sp)
     d30:	03412423          	sw	s4,40(sp)
     d34:	03512223          	sw	s5,36(sp)
     d38:	03612023          	sw	s6,32(sp)
     d3c:	01712e23          	sw	s7,28(sp)
     d40:	01812c23          	sw	s8,24(sp)
     d44:	01912a23          	sw	s9,20(sp)
     d48:	01a12823          	sw	s10,16(sp)
     d4c:	02112e23          	sw	ra,60(sp)
     d50:	02812c23          	sw	s0,56(sp)
     d54:	00050493          	mv	s1,a0
     d58:	00058913          	mv	s2,a1
     d5c:	04c12423          	sw	a2,72(sp)
     d60:	04d12623          	sw	a3,76(sp)
     d64:	04e12823          	sw	a4,80(sp)
     d68:	05012c23          	sw	a6,88(sp)
     d6c:	05112e23          	sw	a7,92(sp)
  va_start(a, format);
     d70:	00f12023          	sw	a5,0(sp)
    if (c == '%') {
     d74:	02500993          	li	s3,37
      if (c == '\n') {
     d78:	00a00b93          	li	s7,10
      switch (c) {
     d7c:	06900a13          	li	s4,105
     d80:	07500a93          	li	s5,117
     d84:	07800c13          	li	s8,120
     d88:	07000c93          	li	s9,112
     d8c:	07300d13          	li	s10,115
     d90:	06300b13          	li	s6,99
  while ((c = *format++)) {
     d94:	00094403          	lbu	s0,0(s2)
     d98:	02041e63          	bnez	s0,dd4 <neorv32_uart_printf+0xbc>
}
     d9c:	03c12083          	lw	ra,60(sp)
     da0:	03812403          	lw	s0,56(sp)
     da4:	03412483          	lw	s1,52(sp)
     da8:	03012903          	lw	s2,48(sp)
     dac:	02c12983          	lw	s3,44(sp)
     db0:	02812a03          	lw	s4,40(sp)
     db4:	02412a83          	lw	s5,36(sp)
     db8:	02012b03          	lw	s6,32(sp)
     dbc:	01c12b83          	lw	s7,28(sp)
     dc0:	01812c03          	lw	s8,24(sp)
     dc4:	01412c83          	lw	s9,20(sp)
     dc8:	01012d03          	lw	s10,16(sp)
     dcc:	06010113          	addi	sp,sp,96
     dd0:	00008067          	ret
    if (c == '%') {
     dd4:	17341463          	bne	s0,s3,f3c <neorv32_uart_printf+0x224>
      c = *format++;
     dd8:	00194403          	lbu	s0,1(s2)
      switch (c) {
     ddc:	03440e63          	beq	s0,s4,e18 <neorv32_uart_printf+0x100>
     de0:	068a6863          	bltu	s4,s0,e50 <neorv32_uart_printf+0x138>
     de4:	13640263          	beq	s0,s6,f08 <neorv32_uart_printf+0x1f0>
     de8:	028b6463          	bltu	s6,s0,e10 <neorv32_uart_printf+0xf8>
          neorv32_uart_putc(UARTx, '%');
     dec:	02500593          	li	a1,37
      switch (c) {
     df0:	13340463          	beq	s0,s3,f18 <neorv32_uart_printf+0x200>
     df4:	05800793          	li	a5,88
     df8:	08f40663          	beq	s0,a5,e84 <neorv32_uart_printf+0x16c>
          neorv32_uart_putc(UARTx, '%');
     dfc:	02500593          	li	a1,37
     e00:	00048513          	mv	a0,s1
     e04:	e91ff0ef          	jal	ra,c94 <neorv32_uart_putc>
          neorv32_uart_putc(UARTx, c);
     e08:	00040593          	mv	a1,s0
     e0c:	10c0006f          	j	f18 <neorv32_uart_printf+0x200>
      switch (c) {
     e10:	06400793          	li	a5,100
     e14:	fef414e3          	bne	s0,a5,dfc <neorv32_uart_printf+0xe4>
          n = (int32_t)va_arg(a, int32_t);
     e18:	00012783          	lw	a5,0(sp)
     e1c:	0007a403          	lw	s0,0(a5)
     e20:	00478713          	addi	a4,a5,4
     e24:	00e12023          	sw	a4,0(sp)
          if (n < 0) {
     e28:	00045a63          	bgez	s0,e3c <neorv32_uart_printf+0x124>
            neorv32_uart_putc(UARTx, '-');
     e2c:	02d00593          	li	a1,45
     e30:	00048513          	mv	a0,s1
            n = -n;
     e34:	40800433          	neg	s0,s0
            neorv32_uart_putc(UARTx, '-');
     e38:	e5dff0ef          	jal	ra,c94 <neorv32_uart_putc>
          __neorv32_uart_itoa((uint32_t)n, string_buf);
     e3c:	00410593          	addi	a1,sp,4
     e40:	00040513          	mv	a0,s0
          __neorv32_uart_itoa(va_arg(a, uint32_t), string_buf);
     e44:	c75ff0ef          	jal	ra,ab8 <__neorv32_uart_itoa>
          neorv32_uart_puts(UARTx, string_buf);
     e48:	00410593          	addi	a1,sp,4
     e4c:	0240006f          	j	e70 <neorv32_uart_printf+0x158>
      switch (c) {
     e50:	0d540a63          	beq	s0,s5,f24 <neorv32_uart_printf+0x20c>
     e54:	028ae663          	bltu	s5,s0,e80 <neorv32_uart_printf+0x168>
     e58:	03940663          	beq	s0,s9,e84 <neorv32_uart_printf+0x16c>
     e5c:	fba410e3          	bne	s0,s10,dfc <neorv32_uart_printf+0xe4>
          neorv32_uart_puts(UARTx, va_arg(a, char*));
     e60:	00012783          	lw	a5,0(sp)
     e64:	0007a583          	lw	a1,0(a5)
     e68:	00478713          	addi	a4,a5,4
     e6c:	00e12023          	sw	a4,0(sp)
          neorv32_uart_puts(UARTx, string_buf);
     e70:	00048513          	mv	a0,s1
     e74:	e39ff0ef          	jal	ra,cac <neorv32_uart_puts>
      c = *format++;
     e78:	00290913          	addi	s2,s2,2
     e7c:	f19ff06f          	j	d94 <neorv32_uart_printf+0x7c>
      switch (c) {
     e80:	f7841ee3          	bne	s0,s8,dfc <neorv32_uart_printf+0xe4>
          __neorv32_uart_tohex(va_arg(a, uint32_t), string_buf);
     e84:	00012783          	lw	a5,0(sp)
     e88:	00410693          	addi	a3,sp,4
  static const char symbols[] = "0123456789abcdef";

  int i;
  for (i=0; i<8; i++) { // nibble by nibble
    uint32_t num_tmp = x >> (4*i);
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     e8c:	00001637          	lui	a2,0x1
          __neorv32_uart_tohex(va_arg(a, uint32_t), string_buf);
     e90:	0007a803          	lw	a6,0(a5)
     e94:	00478713          	addi	a4,a5,4
     e98:	00e12023          	sw	a4,0(sp)
     e9c:	00068593          	mv	a1,a3
     ea0:	00000713          	li	a4,0
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     ea4:	4e460613          	addi	a2,a2,1252 # 14e4 <symbols.0>
  for (i=0; i<8; i++) { // nibble by nibble
     ea8:	02000513          	li	a0,32
    uint32_t num_tmp = x >> (4*i);
     eac:	00e857b3          	srl	a5,a6,a4
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     eb0:	00f7f793          	andi	a5,a5,15
     eb4:	00f607b3          	add	a5,a2,a5
     eb8:	0007c783          	lbu	a5,0(a5)
  for (i=0; i<8; i++) { // nibble by nibble
     ebc:	00470713          	addi	a4,a4,4 # 200004 <__neorv32_ram_size+0x1fe004>
     ec0:	fff68693          	addi	a3,a3,-1 # 7bfffff <__neorv32_ram_size+0x7bfdfff>
    res[7-i] = (char)symbols[num_tmp & 0x0f];
     ec4:	00f68423          	sb	a5,8(a3)
  for (i=0; i<8; i++) { // nibble by nibble
     ec8:	fea712e3          	bne	a4,a0,eac <neorv32_uart_printf+0x194>
  }

  res[8] = '\0'; // terminate result string
     ecc:	00010623          	sb	zero,12(sp)
          if (c == 'X') {
     ed0:	05800793          	li	a5,88
     ed4:	f8f41ee3          	bne	s0,a5,e70 <neorv32_uart_printf+0x158>
     ed8:	00058793          	mv	a5,a1

  char tmp;

  while (len > 0) {
    tmp = *ptr;
    if ((tmp >= 'a') && (tmp <= 'z')) {
     edc:	01900513          	li	a0,25
  while (len > 0) {
     ee0:	00f10613          	addi	a2,sp,15
    tmp = *ptr;
     ee4:	0007c703          	lbu	a4,0(a5)
    if ((tmp >= 'a') && (tmp <= 'z')) {
     ee8:	f9f70693          	addi	a3,a4,-97
     eec:	0ff6f693          	zext.b	a3,a3
     ef0:	00d56663          	bltu	a0,a3,efc <neorv32_uart_printf+0x1e4>
      *ptr = tmp - 32;
     ef4:	fe070713          	addi	a4,a4,-32
     ef8:	00e78023          	sb	a4,0(a5)
    }
    ptr++;
     efc:	00178793          	addi	a5,a5,1
  while (len > 0) {
     f00:	fec792e3          	bne	a5,a2,ee4 <neorv32_uart_printf+0x1cc>
     f04:	f6dff06f          	j	e70 <neorv32_uart_printf+0x158>
          neorv32_uart_putc(UARTx, (char)va_arg(a, int));
     f08:	00012783          	lw	a5,0(sp)
     f0c:	0007c583          	lbu	a1,0(a5)
     f10:	00478713          	addi	a4,a5,4
     f14:	00e12023          	sw	a4,0(sp)
          neorv32_uart_putc(UARTx, '%');
     f18:	00048513          	mv	a0,s1
     f1c:	d79ff0ef          	jal	ra,c94 <neorv32_uart_putc>
          break;
     f20:	f59ff06f          	j	e78 <neorv32_uart_printf+0x160>
          __neorv32_uart_itoa(va_arg(a, uint32_t), string_buf);
     f24:	00012783          	lw	a5,0(sp)
     f28:	00410593          	addi	a1,sp,4
     f2c:	00478713          	addi	a4,a5,4
     f30:	0007a503          	lw	a0,0(a5)
     f34:	00e12023          	sw	a4,0(sp)
     f38:	f0dff06f          	j	e44 <neorv32_uart_printf+0x12c>
      if (c == '\n') {
     f3c:	01741863          	bne	s0,s7,f4c <neorv32_uart_printf+0x234>
        neorv32_uart_putc(UARTx, '\r');
     f40:	00d00593          	li	a1,13
     f44:	00048513          	mv	a0,s1
     f48:	d4dff0ef          	jal	ra,c94 <neorv32_uart_putc>
      neorv32_uart_putc(UARTx, c);
     f4c:	00040593          	mv	a1,s0
     f50:	00048513          	mv	a0,s1
  while ((c = *format++)) {
     f54:	00190913          	addi	s2,s2,1
      neorv32_uart_putc(UARTx, c);
     f58:	d3dff0ef          	jal	ra,c94 <neorv32_uart_putc>
     f5c:	e39ff06f          	j	d94 <neorv32_uart_printf+0x7c>

00000f60 <__divsi3>:
     f60:	06054063          	bltz	a0,fc0 <__umodsi3+0x10>
     f64:	0605c663          	bltz	a1,fd0 <__umodsi3+0x20>

00000f68 <__hidden___udivsi3>:
     f68:	00058613          	mv	a2,a1
     f6c:	00050593          	mv	a1,a0
     f70:	fff00513          	li	a0,-1
     f74:	02060c63          	beqz	a2,fac <__hidden___udivsi3+0x44>
     f78:	00100693          	li	a3,1
     f7c:	00b67a63          	bgeu	a2,a1,f90 <__hidden___udivsi3+0x28>
     f80:	00c05863          	blez	a2,f90 <__hidden___udivsi3+0x28>
     f84:	00161613          	slli	a2,a2,0x1
     f88:	00169693          	slli	a3,a3,0x1
     f8c:	feb66ae3          	bltu	a2,a1,f80 <__hidden___udivsi3+0x18>
     f90:	00000513          	li	a0,0
     f94:	00c5e663          	bltu	a1,a2,fa0 <__hidden___udivsi3+0x38>
     f98:	40c585b3          	sub	a1,a1,a2
     f9c:	00d56533          	or	a0,a0,a3
     fa0:	0016d693          	srli	a3,a3,0x1
     fa4:	00165613          	srli	a2,a2,0x1
     fa8:	fe0696e3          	bnez	a3,f94 <__hidden___udivsi3+0x2c>
     fac:	00008067          	ret

00000fb0 <__umodsi3>:
     fb0:	00008293          	mv	t0,ra
     fb4:	fb5ff0ef          	jal	ra,f68 <__hidden___udivsi3>
     fb8:	00058513          	mv	a0,a1
     fbc:	00028067          	jr	t0
     fc0:	40a00533          	neg	a0,a0
     fc4:	00b04863          	bgtz	a1,fd4 <__umodsi3+0x24>
     fc8:	40b005b3          	neg	a1,a1
     fcc:	f9dff06f          	j	f68 <__hidden___udivsi3>
     fd0:	40b005b3          	neg	a1,a1
     fd4:	00008293          	mv	t0,ra
     fd8:	f91ff0ef          	jal	ra,f68 <__hidden___udivsi3>
     fdc:	40a00533          	neg	a0,a0
     fe0:	00028067          	jr	t0

00000fe4 <__modsi3>:
     fe4:	00008293          	mv	t0,ra
     fe8:	0005ca63          	bltz	a1,ffc <__modsi3+0x18>
     fec:	00054c63          	bltz	a0,1004 <__modsi3+0x20>
     ff0:	f79ff0ef          	jal	ra,f68 <__hidden___udivsi3>
     ff4:	00058513          	mv	a0,a1
     ff8:	00028067          	jr	t0
     ffc:	40b005b3          	neg	a1,a1
    1000:	fe0558e3          	bgez	a0,ff0 <__modsi3+0xc>
    1004:	40a00533          	neg	a0,a0
    1008:	f61ff0ef          	jal	ra,f68 <__hidden___udivsi3>
    100c:	40b00533          	neg	a0,a1
    1010:	00028067          	jr	t0
